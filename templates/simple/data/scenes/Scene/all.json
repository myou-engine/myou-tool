[{"markers":[],"ambient_color":[0.0,0.0,0.0],"fps":24,"gravity":[0,0,-9.800000190734863],"frame_end":250,"type":"SCENE","debug_physics":false,"active_camera":"Camera","frame_start":1,"stereo_eye_separation":0.10000000149011612,"background_color":[0.05087608844041824,0.05087608844041824,0.05087608844041824],"name":"Scene","stereo":false,"sequencer_strips":[]},{"lod_levels":[],"parent":null,"avg_poly_area":1.9999999403953552,"scale":[1.0,1.0,1.0],"elasticity":0.0,"collision_mask":255,"color":[1.0,1.0,1.0,1.0],"friction_coefficients":[1.0,1.0,1.0],"animation_strips":[],"angular_factor":[1,1,1],"is_ghost":false,"position":[0.0,0.0,0.0],"hash":"ace3845809542672842b741a1f4dff1b133027ef","mesh_name":"Cube","type":"MESH","offsets":[0,0,96,36],"linear_factor":[1,1,1],"uv_multiplier":1.0,"all_f":false,"phy_type":"STATIC","materials":["Material"],"offset_scale":[1,1,1],"passes":[0],"dupli_group":null,"matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0],"friction":0.5,"rot":[0,0.0,-0.0,0.0],"parent_bone":"","radius":1.0,"tris_count":12.0,"collision_margin":0.05999999865889549,"properties":{},"stride":16,"anisotropic_friction":false,"rot_mode":"XYZ","scene":"Scene","name":"Cube","actions":[],"shape_multiplier":1.0,"collision_bounds_type":"BOX","mass":1.0,"collision_compound":false,"visible":true,"dimensions":[2.0000009536743164,2.0000009536743164,2.0],"pos":[0.0,0.0,0.0],"collision_group":1,"elements":[["normal"]],"zindex":1,"center":[5.960464477539063e-08,-1.1920928955078125e-07,0.0],"bbox":[-1.0000003576278687,-1.0000005960464478,-1.0,1.0000004768371582,1.0000003576278687,1.0],"no_sleeping":false,"form_factor":0.4000000059604645},{"parent":null,"scale":[1.0,1.0,1.0],"elasticity":0,"collision_mask":255,"color":[1.0,1.0,1.0],"friction_coefficients":[1.0,1.0,1.0],"clip_end":30.00200080871582,"angular_factor":[1,1,1],"is_ghost":false,"position":[4.076245307922363,1.0054539442062378,5.903861999511719],"shadow":true,"clip_start":1.0007989406585693,"falloff_distance":29.999982833862305,"type":"LAMP","linear_factor":[1,1,1],"phy_type":"STATIC","collision_group":1,"offset_scale":[1,1,1],"frustum_size":0,"dupli_group":null,"matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0],"friction":0.5,"tex_size":2880,"rot":[0,0.6503279805183411,0.055217113345861435,1.8663908243179321],"parent_bone":"","radius":1.0,"collision_margin":0.05999999865889549,"properties":{},"anisotropic_friction":false,"rot_mode":"XYZ","scene":"Scene","name":"Lamp","actions":[],"collision_bounds_type":"BOX","mass":1.0,"collision_compound":false,"visible":true,"dimensions":[0.0,0.0,0.0],"pos":[4.076245307922363,1.0054539442062378,5.903861999511719],"lamp_type":"POINT","energy":1,"animation_strips":[],"no_sleeping":false,"form_factor":0.4000000059604645},{"friction_coefficients":[1.0,1.0,1.0],"clip_start":0.10000000149011612,"friction":0.5,"angle":0.8575560450553894,"rot":[0,1.1093189716339111,0.0,0.8149281740188599],"parent_bone":"","radius":1.0,"parent":null,"sensor_fit":"AUTO","elasticity":0,"scale":[1.0,1.0,1.0],"collision_margin":0.05999999865889549,"anisotropic_friction":false,"collision_mask":255,"color":[0.0,0.0,0.0,0.0],"properties":{},"visible":true,"angular_factor":[1,1,1],"cam_type":"PERSP","scene":"Scene","linear_factor":[1,1,1],"name":"Camera","position":[7.481131553649902,-6.5076398849487305,5.34366512298584],"collision_bounds_type":"BOX","actions":[],"is_ghost":false,"form_factor":0.4000000059604645,"type":"CAMERA","mass":1.0,"collision_compound":false,"clip_end":100.0,"animation_strips":[],"rot_mode":"XYZ","dimensions":[0.0,0.0,0.0],"pos":[7.481131553649902,-6.5076398849487305,5.34366512298584],"phy_type":"STATIC","no_sleeping":false,"offset_scale":[1,1,1],"ortho_scale":7.314285755157471,"dupli_group":null,"collision_group":1,"matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0]},{"code":"#extension GL_OES_standard_derivatives : enable\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n/* Converters */\n\nfloat convert_rgba_to_float(vec4 color)\n{\n#ifdef USE_NEW_SHADING\n\treturn color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n#else\n\treturn (color.r + color.g + color.b) / 3.0;\n#endif\n}\n\nfloat exp_blender(float f)\n{\n\treturn pow(2.71828182846, f);\n}\n\nfloat compatible_pow(float x, float y)\n{\n\tif (y == 0.0) /* x^0 -> 1, including 0^0 */\n\t\treturn 1.0;\n\n\t/* glsl pow doesn't accept negative x */\n\tif (x < 0.0) {\n\t\tif (mod(-y, 2.0) == 0.0)\n\t\t\treturn pow(-x, y);\n\t\telse\n\t\t\treturn -pow(-x, y);\n\t}\n\telse if (x == 0.0)\n\t\treturn 0.0;\n\n\treturn pow(x, y);\n}\n\nvoid rgb_to_hsv(vec4 rgb, out vec4 outcol)\n{\n\tfloat cmax, cmin, h, s, v, cdelta;\n\tvec3 c;\n\n\tcmax = max(rgb[0], max(rgb[1], rgb[2]));\n\tcmin = min(rgb[0], min(rgb[1], rgb[2]));\n\tcdelta = cmax - cmin;\n\n\tv = cmax;\n\tif (cmax != 0.0)\n\t\ts = cdelta / cmax;\n\telse {\n\t\ts = 0.0;\n\t\th = 0.0;\n\t}\n\n\tif (s == 0.0) {\n\t\th = 0.0;\n\t}\n\telse {\n\t\tc = (vec3(cmax, cmax, cmax) - rgb.xyz) / cdelta;\n\n\t\tif (rgb.x == cmax) h = c[2] - c[1];\n\t\telse if (rgb.y == cmax) h = 2.0 + c[0] -  c[2];\n\t\telse h = 4.0 + c[1] - c[0];\n\n\t\th /= 6.0;\n\n\t\tif (h < 0.0)\n\t\t\th += 1.0;\n\t}\n\n\toutcol = vec4(h, s, v, rgb.w);\n}\n\nvoid hsv_to_rgb(vec4 hsv, out vec4 outcol)\n{\n\tfloat i, f, p, q, t, h, s, v;\n\tvec3 rgb;\n\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n\n\tif (s == 0.0) {\n\t\trgb = vec3(v, v, v);\n\t}\n\telse {\n\t\tif (h == 1.0)\n\t\t\th = 0.0;\n\n\t\th *= 6.0;\n\t\ti = floor(h);\n\t\tf = h - i;\n\t\trgb = vec3(f, f, f);\n\t\tp = v * (1.0 - s);\n\t\tq = v * (1.0 - (s * f));\n\t\tt = v * (1.0 - (s * (1.0 - f)));\n\n\t\tif (i == 0.0) rgb = vec3(v, t, p);\n\t\telse if (i == 1.0) rgb = vec3(q, v, p);\n\t\telse if (i == 2.0) rgb = vec3(p, v, t);\n\t\telse if (i == 3.0) rgb = vec3(p, q, v);\n\t\telse if (i == 4.0) rgb = vec3(t, p, v);\n\t\telse rgb = vec3(v, p, q);\n\t}\n\n\toutcol = vec4(rgb, hsv.w);\n}\n\nfloat srgb_to_linearrgb(float c)\n{\n\tif (c < 0.04045)\n\t\treturn (c < 0.0) ? 0.0 : c * (1.0 / 12.92);\n\telse\n\t\treturn pow((c + 0.055) * (1.0 / 1.055), 2.4);\n}\n\nfloat linearrgb_to_srgb(float c)\n{\n\tif (c < 0.0031308)\n\t\treturn (c < 0.0) ? 0.0 : c * 12.92;\n\telse\n\t\treturn 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\n\nvoid srgb_to_linearrgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = srgb_to_linearrgb(col_from.r);\n\tcol_to.g = srgb_to_linearrgb(col_from.g);\n\tcol_to.b = srgb_to_linearrgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\nvoid linearrgb_to_srgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = linearrgb_to_srgb(col_from.r);\n\tcol_to.g = linearrgb_to_srgb(col_from.g);\n\tcol_to.b = linearrgb_to_srgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\nvoid color_to_normal(vec3 color, out vec3 normal)\n{\n\tnormal.x =  2.0 * ((color.r) - 0.5);\n\tnormal.y = -2.0 * ((color.g) - 0.5);\n\tnormal.z =  2.0 * ((color.b) - 0.5);\n}\n\nvoid color_to_normal_new_shading(vec3 color, out vec3 normal)\n{\n\tnormal.x =  2.0 * ((color.r) - 0.5);\n\tnormal.y =  2.0 * ((color.g) - 0.5);\n\tnormal.z =  2.0 * ((color.b) - 0.5);\n}\n\nvoid color_to_blender_normal_new_shading(vec3 color, out vec3 normal)\n{\n\tnormal.x =  2.0 * ((color.r) - 0.5);\n\tnormal.y = -2.0 * ((color.g) - 0.5);\n\tnormal.z = -2.0 * ((color.b) - 0.5);\n}\n\n#define M_PI 3.14159265358979323846\n#define M_1_PI 0.31830988618379069\n\n/*********** SHADER NODES ***************/\n\nvoid vcol_attribute(vec4 attvcol, out vec4 vcol)\n{\n\tvcol = vec4(attvcol.x, attvcol.y, attvcol.z, 1.0);\n}\n\nvoid uv_attribute(vec2 attuv, out vec3 uv)\n{\n\tuv = vec3(attuv * 2.0 - vec2(1.0, 1.0), 0.0);\n}\n\nvoid geom(\n        vec3 co, vec3 nor, mat4 viewinvmat, vec3 attorco, vec2 attuv, vec4 attvcol,\n        out vec3 global, out vec3 local, out vec3 view, out vec3 orco, out vec3 uv,\n        out vec3 normal, out vec4 vcol, out float vcol_alpha, out float frontback)\n{\n\tlocal = co;\n\tview = (0.0 == 0.0) ? normalize(local) : vec3(0.0, 0.0, -1.0);\n\tglobal = (viewinvmat * vec4(local, 1.0)).xyz;\n\torco = attorco;\n\tuv_attribute(attuv, uv);\n\tnormal = -normalize(nor);   /* blender render normal is negated */\n\tvcol_attribute(attvcol, vcol);\n\tsrgb_to_linearrgb(vcol, vcol);\n\tvcol_alpha = attvcol.a;\n\tfrontback = (gl_FrontFacing) ? 1.0 : 0.0;\n}\n\nvoid particle_info(\n        vec4 sprops, vec3 loc, vec3 vel, vec3 avel,\n        out float index, out float age, out float life_time, out vec3 location,\n        out float size, out vec3 velocity, out vec3 angular_velocity)\n{\n\tindex = sprops.x;\n\tage = sprops.y;\n\tlife_time = sprops.z;\n\tsize = sprops.w;\n\n\tlocation = loc;\n\tvelocity = vel;\n\tangular_velocity = avel;\n}\n\nvoid vect_normalize(vec3 vin, out vec3 vout)\n{\n\tvout = normalize(vin);\n}\n\nvoid direction_transform_m4v3(vec3 vin, mat4 mat, out vec3 vout)\n{\n\tvout = (mat * vec4(vin, 0.0)).xyz;\n}\n\nvoid point_transform_m4v3(vec3 vin, mat4 mat, out vec3 vout)\n{\n\tvout = (mat * vec4(vin, 1.0)).xyz;\n}\n\nvoid point_texco_remap_square(vec3 vin, out vec3 vout)\n{\n\tvout = vec3(vin - vec3(0.5, 0.5, 0.5)) * 2.0;\n}\n\nvoid point_map_to_sphere(vec3 vin, out vec3 vout)\n{\n\tfloat len = length(vin);\n\tfloat v, u;\n\tif (len > 0.0) {\n\t\tif (vin.x == 0.0 && vin.y == 0.0)\n\t\t\tu = 0.0;\n\t\telse\n\t\t\tu = (1.0 - atan(vin.x, vin.y) / M_PI) / 2.0;\n\n\t\tv = 1.0 - acos(vin.z / len) / M_PI;\n\t}\n\telse\n\t\tv = u = 0.0;\n\n\tvout = vec3(u, v, 0.0);\n}\n\nvoid point_map_to_tube(vec3 vin, out vec3 vout)\n{\n\tfloat u, v;\n\tv = (vin.z + 1.0) * 0.5;\n\tfloat len = sqrt(vin.x * vin.x + vin.y * vin[1]);\n\tif (len > 0.0)\n\t\tu = (1.0 - (atan(vin.x / len, vin.y / len) / M_PI)) * 0.5;\n\telse\n\t\tv = u = 0.0;\n\n\tvout = vec3(u, v, 0.0);\n}\n\nvoid mapping(vec3 vec, mat4 mat, vec3 minvec, vec3 maxvec, float domin, float domax, out vec3 outvec)\n{\n\toutvec = (mat * vec4(vec, 1.0)).xyz;\n\tif (domin == 1.0)\n\t\toutvec = max(outvec, minvec);\n\tif (domax == 1.0)\n\t\toutvec = min(outvec, maxvec);\n}\n\nvoid camera(vec3 co, out vec3 outview, out float outdepth, out float outdist)\n{\n\toutdepth = abs(co.z);\n\toutdist = length(co);\n\toutview = normalize(co);\n}\n\nvoid lamp(\n        vec4 col, float energy, vec3 lv, float dist, vec3 shadow, float visifac,\n        out vec4 outcol, out vec3 outlv, out float outdist, out vec4 outshadow, out float outvisifac)\n{\n\toutcol = col * energy;\n\toutlv = lv;\n\toutdist = dist;\n\toutshadow = vec4(shadow, 1.0);\n\toutvisifac = visifac;\n}\n\nvoid math_add(float val1, float val2, out float outval)\n{\n\toutval = val1 + val2;\n}\n\nvoid math_subtract(float val1, float val2, out float outval)\n{\n\toutval = val1 - val2;\n}\n\nvoid math_multiply(float val1, float val2, out float outval)\n{\n\toutval = val1 * val2;\n}\n\nvoid math_divide(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = val1 / val2;\n}\n\nvoid math_sine(float val, out float outval)\n{\n\toutval = sin(val);\n}\n\nvoid math_cosine(float val, out float outval)\n{\n\toutval = cos(val);\n}\n\nvoid math_tangent(float val, out float outval)\n{\n\toutval = tan(val);\n}\n\nvoid math_asin(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = asin(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_acos(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = acos(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_atan(float val, out float outval)\n{\n\toutval = atan(val);\n}\n\nvoid math_pow(float val1, float val2, out float outval)\n{\n\tif (val1 >= 0.0) {\n\t\toutval = compatible_pow(val1, val2);\n\t}\n\telse {\n\t\tfloat val2_mod_1 = mod(abs(val2), 1.0);\n\n\t\tif (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\n\t\t\toutval = compatible_pow(val1, floor(val2 + 0.5));\n\t\telse\n\t\t\toutval = 0.0;\n\t}\n}\n\nvoid math_log(float val1, float val2, out float outval)\n{\n\tif (val1 > 0.0  && val2 > 0.0)\n\t\toutval = log2(val1) / log2(val2);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_max(float val1, float val2, out float outval)\n{\n\toutval = max(val1, val2);\n}\n\nvoid math_min(float val1, float val2, out float outval)\n{\n\toutval = min(val1, val2);\n}\n\nvoid math_round(float val, out float outval)\n{\n\toutval = floor(val + 0.5);\n}\n\nvoid math_less_than(float val1, float val2, out float outval)\n{\n\tif (val1 < val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_greater_than(float val1, float val2, out float outval)\n{\n\tif (val1 > val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_modulo(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = mod(val1, val2);\n\n\t/* change sign to match C convention, mod in GLSL will take absolute for negative numbers,\n\t * see https://www.opengl.org/sdk/docs/man/html/mod.xhtml */\n\toutval = (val1 > 0.0) ? outval : -outval;\n}\n\nvoid math_abs(float val1, out float outval)\n{\n\toutval = abs(val1);\n}\n\nvoid squeeze(float val, float width, float center, out float outval)\n{\n\toutval = 1.0 / (1.0 + pow(2.71828183, -((val - center) * width)));\n}\n\nvoid vec_math_add(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2])) / 3.0;\n}\n\nvoid vec_math_sub(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 - v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2])) / 3.0;\n}\n\nvoid vec_math_average(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = length(outvec);\n\toutvec = normalize(outvec);\n}\nvoid vec_math_mix(float strength, vec3 v1, vec3 v2, out vec3 outvec)\n{\n\toutvec = strength * v1 + (1.0 - strength) * v2;\n}\n\nvoid vec_math_dot(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = vec3(0, 0, 0);\n\toutval = dot(v1, v2);\n}\n\nvoid vec_math_cross(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = cross(v1, v2);\n\toutval = length(outvec);\n\toutvec /= outval;\n}\n\nvoid vec_math_normalize(vec3 v, out vec3 outvec, out float outval)\n{\n\toutval = length(v);\n\toutvec = normalize(v);\n}\n\nvoid vec_math_negate(vec3 v, out vec3 outv)\n{\n\toutv = vec3(0.0)-v;\n}\n\nvoid invert_z(vec3 v, out vec3 outv)\n{\n\tv.z = -v.z;\n\toutv = v;\n}\n\nvoid normal(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\n{\n\toutnor = nor;\n\toutdot = -dot(dir, nor);\n}\n\nvoid normal_new_shading(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\n{\n\toutnor = normalize(nor);\n\toutdot = dot(normalize(dir), nor);\n}\n\nvoid curves_vec(float fac, vec3 vec, sampler2D curvemap, out vec3 outvec)\n{\n\toutvec.x = texture2D(curvemap, vec2((vec.x + 1.0) * 0.5, 0.0)).x;\n\toutvec.y = texture2D(curvemap, vec2((vec.y + 1.0) * 0.5, 0.0)).y;\n\toutvec.z = texture2D(curvemap, vec2((vec.z + 1.0) * 0.5, 0.0)).z;\n\n\tif (fac != 1.0)\n\t\toutvec = (outvec * fac) + (vec * (1.0 - fac));\n\n}\n\nvoid curves_rgb(float fac, vec4 col, sampler2D curvemap, out vec4 outcol)\n{\n\toutcol.r = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.r, 0.0)).a, 0.0)).r;\n\toutcol.g = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.g, 0.0)).a, 0.0)).g;\n\toutcol.b = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.b, 0.0)).a, 0.0)).b;\n\n\tif (fac != 1.0)\n\t\toutcol = (outcol * fac) + (col * (1.0 - fac));\n\n\toutcol.a = col.a;\n}\n\nvoid set_value(float val, out float outval)\n{\n\toutval = val;\n}\n\nvoid set_rgb(vec3 col, out vec3 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_rgba(vec4 col, out vec4 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_value_zero(out float outval)\n{\n\toutval = 0.0;\n}\n\nvoid set_value_one(out float outval)\n{\n\toutval = 1.0;\n}\n\nvoid set_rgb_zero(out vec3 outval)\n{\n\toutval = vec3(0.0);\n}\n\nvoid set_rgb_one(out vec3 outval)\n{\n\toutval = vec3(1.0);\n}\n\nvoid set_rgba_zero(out vec4 outval)\n{\n\toutval = vec4(0.0);\n}\n\nvoid set_rgba_one(out vec4 outval)\n{\n\toutval = vec4(1.0);\n}\n\nvoid brightness_contrast(vec4 col, float brightness, float contrast, out vec4 outcol)\n{\n\tfloat a = 1.0 + contrast;\n\tfloat b = brightness - contrast * 0.5;\n\n\toutcol.r = max(a * col.r + b, 0.0);\n\toutcol.g = max(a * col.g + b, 0.0);\n\toutcol.b = max(a * col.b + b, 0.0);\n\toutcol.a = col.a;\n}\n\nvoid mix_blend(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_add(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 + col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_mult(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 * col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_screen(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = vec4(1.0) - (vec4(facm) + fac * (vec4(1.0) - col2)) * (vec4(1.0) - col1);\n\toutcol.a = col1.a;\n}\n\nvoid mix_overlay(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif (outcol.r < 0.5)\n\t\toutcol.r *= facm + 2.0 * fac * col2.r;\n\telse\n\t\toutcol.r = 1.0 - (facm + 2.0 * fac * (1.0 - col2.r)) * (1.0 - outcol.r);\n\n\tif (outcol.g < 0.5)\n\t\toutcol.g *= facm + 2.0 * fac * col2.g;\n\telse\n\t\toutcol.g = 1.0 - (facm + 2.0 * fac * (1.0 - col2.g)) * (1.0 - outcol.g);\n\n\tif (outcol.b < 0.5)\n\t\toutcol.b *= facm + 2.0 * fac * col2.b;\n\telse\n\t\toutcol.b = 1.0 - (facm + 2.0 * fac * (1.0 - col2.b)) * (1.0 - outcol.b);\n}\n\nvoid mix_sub(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 - col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_div(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif (col2.r != 0.0) outcol.r = facm * outcol.r + fac * outcol.r / col2.r;\n\tif (col2.g != 0.0) outcol.g = facm * outcol.g + fac * outcol.g / col2.g;\n\tif (col2.b != 0.0) outcol.b = facm * outcol.b + fac * outcol.b / col2.b;\n}\n\nvoid mix_diff(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, abs(col1 - col2), fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dark(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = min(col1.rgb, col2.rgb * fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_light(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = max(col1.rgb, col2.rgb * fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dodge(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = col1;\n\n\tif (outcol.r != 0.0) {\n\t\tfloat tmp = 1.0 - fac * col2.r;\n\t\tif (tmp <= 0.0)\n\t\t\toutcol.r = 1.0;\n\t\telse if ((tmp = outcol.r / tmp) > 1.0)\n\t\t\toutcol.r = 1.0;\n\t\telse\n\t\t\toutcol.r = tmp;\n\t}\n\tif (outcol.g != 0.0) {\n\t\tfloat tmp = 1.0 - fac * col2.g;\n\t\tif (tmp <= 0.0)\n\t\t\toutcol.g = 1.0;\n\t\telse if ((tmp = outcol.g / tmp) > 1.0)\n\t\t\toutcol.g = 1.0;\n\t\telse\n\t\t\toutcol.g = tmp;\n\t}\n\tif (outcol.b != 0.0) {\n\t\tfloat tmp = 1.0 - fac * col2.b;\n\t\tif (tmp <= 0.0)\n\t\t\toutcol.b = 1.0;\n\t\telse if ((tmp = outcol.b / tmp) > 1.0)\n\t\t\toutcol.b = 1.0;\n\t\telse\n\t\t\toutcol.b = tmp;\n\t}\n}\n\nvoid mix_burn(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat tmp, facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\ttmp = facm + fac * col2.r;\n\tif (tmp <= 0.0)\n\t\toutcol.r = 0.0;\n\telse if ((tmp = (1.0 - (1.0 - outcol.r) / tmp)) < 0.0)\n\t\toutcol.r = 0.0;\n\telse if (tmp > 1.0)\n\t\toutcol.r = 1.0;\n\telse\n\t\toutcol.r = tmp;\n\n\ttmp = facm + fac * col2.g;\n\tif (tmp <= 0.0)\n\t\toutcol.g = 0.0;\n\telse if ((tmp = (1.0 - (1.0 - outcol.g) / tmp)) < 0.0)\n\t\toutcol.g = 0.0;\n\telse if (tmp > 1.0)\n\t\toutcol.g = 1.0;\n\telse\n\t\toutcol.g = tmp;\n\n\ttmp = facm + fac * col2.b;\n\tif (tmp <= 0.0)\n\t\toutcol.b = 0.0;\n\telse if ((tmp = (1.0 - (1.0 - outcol.b) / tmp)) < 0.0)\n\t\toutcol.b = 0.0;\n\telse if (tmp > 1.0)\n\t\toutcol.b = 1.0;\n\telse\n\t\toutcol.b = tmp;\n}\n\nvoid mix_hue(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif (hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv_to_rgb(hsv, tmp);\n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_sat(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(outcol, hsv);\n\n\tif (hsv.y != 0.0) {\n\t\trgb_to_hsv(col2, hsv2);\n\n\t\thsv.y = facm * hsv.y + fac * hsv2.y;\n\t\thsv_to_rgb(hsv, outcol);\n\t}\n}\n\nvoid mix_val(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(col1, hsv);\n\trgb_to_hsv(col2, hsv2);\n\n\thsv.z = facm * hsv.z + fac * hsv2.z;\n\thsv_to_rgb(hsv, outcol);\n}\n\nvoid mix_color(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif (hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv.y = hsv2.y;\n\t\thsv_to_rgb(hsv, tmp);\n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_soft(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 one = vec4(1.0);\n\tvec4 scr = one - (one - col2) * (one - col1);\n\toutcol = facm * col1 + fac * ((one - col1) * col2 * col1 + col1 * scr);\n}\n\nvoid mix_linear(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\n\toutcol = col1 + fac * (2.0 * (col2 - vec4(0.5)));\n}\n\nvoid valtorgb(float fac, sampler2D colormap, out vec4 outcol, out float outalpha)\n{\n\toutcol = texture2D(colormap, vec2(fac, 0.0));\n\toutalpha = outcol.a;\n}\n\nvoid rgbtobw(vec4 color, out float outval)\n{\n#ifdef USE_NEW_SHADING\n\toutval = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n#else\n\toutval = color.r * 0.35 + color.g * 0.45 + color.b * 0.2; /* keep these factors in sync with texture.h:RGBTOBW */\n#endif\n}\n\nvoid invert(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\n\toutcol.w = col.w;\n}\n\nvoid clamp_vec3(vec3 vec, vec3 min, vec3 max, out vec3 out_vec)\n{\n\tout_vec = clamp(vec, min, max);\n}\n\nvoid clamp_val(float value, float min, float max, out float out_value)\n{\n\tout_value = clamp(value, min, max);\n}\n\nvoid hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outcol)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\n\thsv[0] += (hue - 0.5);\n\tif (hsv[0] > 1.0) hsv[0] -= 1.0; else if (hsv[0] < 0.0) hsv[0] += 1.0;\n\thsv[1] *= sat;\n\tif (hsv[1] > 1.0) hsv[1] = 1.0; else if (hsv[1] < 0.0) hsv[1] = 0.0;\n\thsv[2] *= value;\n\tif (hsv[2] > 1.0) hsv[2] = 1.0; else if (hsv[2] < 0.0) hsv[2] = 0.0;\n\n\thsv_to_rgb(hsv, outcol);\n\n\toutcol = mix(col, outcol, fac);\n}\n\nvoid separate_rgb(vec4 col, out float r, out float g, out float b)\n{\n\tr = col.r;\n\tg = col.g;\n\tb = col.b;\n}\n\nvoid combine_rgb(float r, float g, float b, out vec4 col)\n{\n\tcol = vec4(r, g, b, 1.0);\n}\n\nvoid separate_xyz(vec3 vec, out float x, out float y, out float z)\n{\n\tx = vec.r;\n\ty = vec.g;\n\tz = vec.b;\n}\n\nvoid combine_xyz(float x, float y, float z, out vec3 vec)\n{\n\tvec = vec3(x, y, z);\n}\n\nvoid separate_hsv(vec4 col, out float h, out float s, out float v)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n}\n\nvoid combine_hsv(float h, float s, float v, out vec4 col)\n{\n\thsv_to_rgb(vec4(h, s, v, 1.0), col);\n}\n\nvoid output_node(vec4 rgb, float alpha, out vec4 outrgb)\n{\n\toutrgb = vec4(rgb.rgb, alpha);\n}\n\n/*********** TEXTURES ***************/\n\nvoid texture_flip_blend(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec.yxz;\n}\n\nvoid texture_blend_lin(vec3 vec, out float outval)\n{\n\toutval = (1.0 + vec.x) / 2.0;\n}\n\nvoid texture_blend_quad(vec3 vec, out float outval)\n{\n\toutval = max((1.0 + vec.x) / 2.0, 0.0);\n\toutval *= outval;\n}\n\nvoid texture_wood_sin(vec3 vec, out float value, out vec4 color, out vec3 normal)\n{\n\tfloat a = sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z) * 20.0;\n\tfloat wi = 0.5 + 0.5 * sin(a);\n\n\tvalue = wi;\n\tcolor = vec4(wi, wi, wi, 1.0);\n\tnormal = vec3(0.0, 0.0, 0.0);\n}\n\nvoid texture_image(vec3 vec, sampler2D ima, out float value, out vec4 color, out vec3 normal)\n{\n\tcolor = texture2D(ima, (vec.xy + vec2(1.0, 1.0)) * 0.5);\n\tvalue = color.a;\n\n\tnormal.x = 2.0 * (color.r - 0.5);\n\tnormal.y = 2.0 * (0.5 - color.g);\n\tnormal.z = 2.0 * (color.b - 0.5);\n}\n\n/************* MTEX *****************/\n\nvoid texco_orco(vec3 attorco, out vec3 orco)\n{\n\torco = attorco;\n}\n\nvoid texco_uv(vec2 attuv, out vec3 uv)\n{\n\t/* disabled for now, works together with leaving out mtex_2d_mapping\n\t   uv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0); */\n\tuv = vec3(attuv, 0.0);\n}\n\nvoid texco_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* corresponds to shi->orn, which is negated so cancels\n\t   out blender normal negation */\n\toutnormal = normalize(normal);\n}\n\nvoid texco_tangent(vec4 tangent, out vec3 outtangent)\n{\n\touttangent = normalize(tangent.xyz);\n}\n\nvoid texco_global(mat4 viewinvmat, vec3 co, out vec3 global)\n{\n\tglobal = (viewinvmat * vec4(co, 1.0)).xyz;\n}\n\nvoid texco_object(mat4 viewinvmat, mat4 obinvmat, vec3 co, out vec3 object)\n{\n\tobject = (obinvmat * (viewinvmat * vec4(co, 1.0))).xyz;\n}\n\nvoid texco_refl(vec3 vn, vec3 view, out vec3 ref)\n{\n\tref = view - 2.0 * dot(vn, view) * vn;\n}\n\nvoid shade_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* blender render normal is negated */\n\toutnormal = -normalize(normal);\n}\n\nvoid mtex_mirror(vec3 tcol, vec4 refcol, float tin, float colmirfac, out vec4 outrefcol)\n{\n\toutrefcol = mix(refcol, vec4(1.0, tcol), tin * colmirfac);\n}\n\nvoid mtex_rgb_blend(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol = fact * texcol + facm * outcol;\n}\n\nvoid mtex_rgb_mul(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol = (facm + fact * texcol) * outcol;\n}\n\nvoid mtex_rgb_screen(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol = vec3(1.0) - (vec3(facm) + fact * (vec3(1.0) - texcol)) * (vec3(1.0) - outcol);\n}\n\nvoid mtex_rgb_overlay(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tif (outcol.r < 0.5)\n\t\tincol.r = outcol.r * (facm + 2.0 * fact * texcol.r);\n\telse\n\t\tincol.r = 1.0 - (facm + 2.0 * fact * (1.0 - texcol.r)) * (1.0 - outcol.r);\n\n\tif (outcol.g < 0.5)\n\t\tincol.g = outcol.g * (facm + 2.0 * fact * texcol.g);\n\telse\n\t\tincol.g = 1.0 - (facm + 2.0 * fact * (1.0 - texcol.g)) * (1.0 - outcol.g);\n\n\tif (outcol.b < 0.5)\n\t\tincol.b = outcol.b * (facm + 2.0 * fact * texcol.b);\n\telse\n\t\tincol.b = 1.0 - (facm + 2.0 * fact * (1.0 - texcol.b)) * (1.0 - outcol.b);\n}\n\nvoid mtex_rgb_sub(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = -fact * facg * texcol + outcol;\n}\n\nvoid mtex_rgb_add(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = fact * facg * texcol + outcol;\n}\n\nvoid mtex_rgb_div(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tif (texcol.r != 0.0) incol.r = facm * outcol.r + fact * outcol.r / texcol.r;\n\tif (texcol.g != 0.0) incol.g = facm * outcol.g + fact * outcol.g / texcol.g;\n\tif (texcol.b != 0.0) incol.b = facm * outcol.b + fact * outcol.b / texcol.b;\n}\n\nvoid mtex_rgb_diff(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol = facm * outcol + fact * abs(texcol - outcol);\n}\n\nvoid mtex_rgb_dark(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol.r = min(outcol.r, texcol.r) * fact + outcol.r * facm;\n\tincol.g = min(outcol.g, texcol.g) * fact + outcol.g * facm;\n\tincol.b = min(outcol.b, texcol.b) * fact + outcol.b * facm;\n}\n\nvoid mtex_rgb_light(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\n\tcol = fact * texcol.r;\n\tif (col > outcol.r) incol.r = col; else incol.r = outcol.r;\n\tcol = fact * texcol.g;\n\tif (col > outcol.g) incol.g = col; else incol.g = outcol.g;\n\tcol = fact * texcol.b;\n\tif (col > outcol.b) incol.b = col; else incol.b = outcol.b;\n}\n\nvoid mtex_rgb_hue(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_hue(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_sat(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_sat(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_val(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_val(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_color(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_color(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_soft(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_soft(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_linear(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfact *= facg;\n\n\tif (texcol.r > 0.5)\n\t\tincol.r = outcol.r + fact * (2.0 * (texcol.r - 0.5));\n\telse\n\t\tincol.r = outcol.r + fact * (2.0 * (texcol.r) - 1.0);\n\n\tif (texcol.g > 0.5)\n\t\tincol.g = outcol.g + fact * (2.0 * (texcol.g - 0.5));\n\telse\n\t\tincol.g = outcol.g + fact * (2.0 * (texcol.g) - 1.0);\n\n\tif (texcol.b > 0.5)\n\t\tincol.b = outcol.b + fact * (2.0 * (texcol.b - 0.5));\n\telse\n\t\tincol.b = outcol.b + fact * (2.0 * (texcol.b) - 1.0);\n}\n\nvoid mtex_value_vars(inout float fact, float facg, out float facm)\n{\n\tfact *= abs(facg);\n\tfacm = 1.0 - fact;\n\n\tif (facg < 0.0) {\n\t\tfloat tmp = fact;\n\t\tfact = facm;\n\t\tfacm = tmp;\n\t}\n}\n\nvoid mtex_value_blend(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = fact * texcol + facm * outcol;\n}\n\nvoid mtex_value_mul(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = (facm + fact * texcol) * outcol;\n}\n\nvoid mtex_value_screen(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = 1.0 - (facm + fact * (1.0 - texcol)) * (1.0 - outcol);\n}\n\nvoid mtex_value_sub(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = -fact;\n\tincol = fact * texcol + outcol;\n}\n\nvoid mtex_value_add(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = fact;\n\tincol = fact * texcol + outcol;\n}\n\nvoid mtex_value_div(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tif (texcol != 0.0)\n\t\tincol = facm * outcol + fact * outcol / texcol;\n\telse\n\t\tincol = 0.0;\n}\n\nvoid mtex_value_diff(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm * outcol + fact * abs(texcol - outcol);\n}\n\nvoid mtex_value_dark(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm * outcol + fact * min(outcol, texcol);\n}\n\nvoid mtex_value_light(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfloat col = fact * texcol;\n\tif (col > outcol) incol = col; else incol = outcol;\n}\n\nvoid mtex_value_clamp_positive(float fac, out float outfac)\n{\n\toutfac = max(fac, 0.0);\n}\n\nvoid mtex_value_clamp(float fac, out float outfac)\n{\n\toutfac = clamp(fac, 0.0, 1.0);\n}\n\nvoid mtex_har_divide(float har, out float outhar)\n{\n\touthar = har / 128.0;\n}\n\nvoid mtex_har_multiply_clamp(float har, out float outhar)\n{\n\thar *= 128.0;\n\n\tif (har < 1.0) outhar = 1.0;\n\telse if (har > 511.0) outhar = 511.0;\n\telse outhar = har;\n}\n\nvoid mtex_alpha_from_col(vec4 col, out float alpha)\n{\n\talpha = col.a;\n}\n\nvoid mtex_alpha_to_col(vec4 col, float alpha, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, alpha);\n}\n\nvoid mtex_alpha_multiply_value(vec4 col, float value, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, col.a * value);\n}\n\nvoid mtex_rgbtoint(vec4 rgb, out float intensity)\n{\n\tintensity = dot(vec3(0.35, 0.45, 0.2), rgb.rgb);\n}\n\nvoid mtex_value_invert(float invalue, out float outvalue)\n{\n\toutvalue = 1.0 - invalue;\n}\n\nvoid mtex_rgb_invert(vec4 inrgb, out vec4 outrgb)\n{\n\toutrgb = vec4(vec3(1.0) - inrgb.rgb, inrgb.a);\n}\n\nvoid mtex_value_stencil(float stencil, float intensity, out float outstencil, out float outintensity)\n{\n\tfloat fact = intensity;\n\toutintensity = intensity * stencil;\n\toutstencil = stencil * fact;\n}\n\nvoid mtex_rgb_stencil(float stencil, vec4 rgb, out float outstencil, out vec4 outrgb)\n{\n\tfloat fact = rgb.a;\n\toutrgb = vec4(rgb.rgb, rgb.a * stencil);\n\toutstencil = stencil * fact;\n}\n\nvoid mtex_mapping_ofs(vec3 texco, vec3 ofs, out vec3 outtexco)\n{\n\touttexco = texco + ofs;\n}\n\nvoid mtex_mapping_size(vec3 texco, vec3 size, out vec3 outtexco)\n{\n\touttexco = size * texco;\n}\n\nvoid mtex_2d_mapping(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec3(vec.xy * 0.5 + vec2(0.5), vec.z);\n}\n\nvec3 mtex_2d_mapping(vec3 vec)\n{\n\treturn vec3(vec.xy * 0.5 + vec2(0.5), vec.z);\n}\n\nvoid mtex_cube_map(vec3 co, samplerCube ima, out float value, out vec4 color)\n{\n\tcolor = textureCube(ima, co);\n\tvalue = 1.0;\n}\n\nvoid mtex_cube_map_refl_from_refldir(\n        samplerCube ima, vec3 reflecteddirection, out float value, out vec4 color)\n{\n        color = textureCube(ima, reflecteddirection);\n        value = 1.0;\n}\n\nvoid mtex_cube_map_refl(\n        samplerCube ima, vec3 vp, vec3 vn, mat4 viewmatrixinverse, mat4 viewmatrix,\n        out float value, out vec4 color)\n{\n\tvec3 viewdirection = vec3(viewmatrixinverse * vec4(vp, 0.0));\n\tvec3 normaldirection = normalize(vec3(vec4(vn, 0.0) * viewmatrix));\n\tvec3 reflecteddirection = reflect(viewdirection, normaldirection);\n\tcolor = textureCube(ima, reflecteddirection);\n\tvalue = 1.0;\n}\n\nvoid mtex_image(vec3 texco, sampler2D ima, out float value, out vec4 color)\n{\n\tcolor = texture2D(ima, texco.xy);\n\tvalue = 1.0;\n}\n\nvoid mtex_normal(vec3 texco, sampler2D ima, out vec3 normal)\n{\n\t// The invert of the red channel is to make\n\t// the normal map compliant with the outside world.\n\t// It needs to be done because in Blender\n\t// the normal used points inward.\n\t// Should this ever change this negate must be removed.\n\tvec4 color = texture2D(ima, texco.xy);\n\tnormal = 2.0 * (vec3(-color.r, color.g, color.b) - vec3(-0.5, 0.5, 0.5));\n}\n\nvoid mtex_bump_normals_init(vec3 vN, out vec3 vNorg, out vec3 vNacc, out float fPrevMagnitude)\n{\n\tvNorg = vN;\n\tvNacc = vN;\n\tfPrevMagnitude = 1.0;\n}\n\n/** helper method to extract the upper left 3x3 matrix from a 4x4 matrix */\nmat3 to_mat3(mat4 m4)\n{\n\tmat3 m3;\n\tm3[0] = m4[0].xyz;\n\tm3[1] = m4[1].xyz;\n\tm3[2] = m4[2].xyz;\n\treturn m3;\n}\n\nvoid mtex_bump_init_objspace(\n        vec3 surf_pos, vec3 surf_norm,\n        mat4 mView, mat4 mViewInv, mat4 mObj, mat4 mObjInv,\n        float fPrevMagnitude_in, vec3 vNacc_in,\n        out float fPrevMagnitude_out, out vec3 vNacc_out,\n        out vec3 vR1, out vec3 vR2, out float fDet)\n{\n\tmat3 obj2view = to_mat3(mat4(1));\n\tmat3 view2obj = to_mat3(mat4(1));\n\n\tvec3 vSigmaS = view2obj * dFdx(surf_pos);\n\tvec3 vSigmaT = view2obj * dFdy(surf_pos);\n\tvec3 vN = normalize(surf_norm * obj2view);\n\n\tvR1 = cross(vSigmaT, vN);\n\tvR2 = cross(vN, vSigmaS);\n\tfDet = dot(vSigmaS, vR1);\n\n\t/* pretransform vNacc (in mtex_bump_apply) using the inverse transposed */\n\tvR1 = vR1 * view2obj;\n\tvR2 = vR2 * view2obj;\n\tvN = vN * view2obj;\n\n\tfloat fMagnitude = abs(fDet) * length(vN);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_texturespace(\n        vec3 surf_pos, vec3 surf_norm,\n        float fPrevMagnitude_in, vec3 vNacc_in,\n        out float fPrevMagnitude_out, out vec3 vNacc_out,\n        out vec3 vR1, out vec3 vR2, out float fDet)\n{\n\tvec3 vSigmaS = dFdx(surf_pos);\n\tvec3 vSigmaT = dFdy(surf_pos);\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\n\tvR1 = normalize(cross(vSigmaT, vN));\n\tvR2 = normalize(cross(vN, vSigmaS));\n\tfDet = sign(dot(vSigmaS, vR1));\n\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_viewspace(\n        vec3 surf_pos, vec3 surf_norm,\n        float fPrevMagnitude_in, vec3 vNacc_in,\n        out float fPrevMagnitude_out, out vec3 vNacc_out,\n        out vec3 vR1, out vec3 vR2, out float fDet)\n{\n\tvec3 vSigmaS = dFdx(surf_pos);\n\tvec3 vSigmaT = dFdy(surf_pos);\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\n\tvR1 = cross(vSigmaT, vN);\n\tvR2 = cross(vN, vSigmaS);\n\tfDet = dot(vSigmaS, vR1);\n\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_tap3(\n        vec3 texco, sampler2D ima, float hScale,\n        out float dBs, out float dBt)\n{\n\tvec2 STll = texco.xy;\n\tvec2 STlr = texco.xy + dFdx(texco.xy);\n\tvec2 STul = texco.xy + dFdy(texco.xy);\n\n\tfloat Hll, Hlr, Hul;\n\trgbtobw(texture2D(ima, STll), Hll);\n\trgbtobw(texture2D(ima, STlr), Hlr);\n\trgbtobw(texture2D(ima, STul), Hul);\n\n\tdBs = hScale * (Hlr - Hll);\n\tdBt = hScale * (Hul - Hll);\n}\n\n#ifdef BUMP_BICUBIC\n\nvoid mtex_bump_bicubic(\n        vec3 texco, sampler2D ima, float hScale,\n        out float dBs, out float dBt )\n{\n\tfloat Hl;\n\tfloat Hr;\n\tfloat Hd;\n\tfloat Hu;\n\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec2 STl = texco.xy - 0.5 * TexDx;\n\tvec2 STr = texco.xy + 0.5 * TexDx;\n\tvec2 STd = texco.xy - 0.5 * TexDy;\n\tvec2 STu = texco.xy + 0.5 * TexDy;\n\n\trgbtobw(texture2D(ima, STl), Hl);\n\trgbtobw(texture2D(ima, STr), Hr);\n\trgbtobw(texture2D(ima, STd), Hd);\n\trgbtobw(texture2D(ima, STu), Hu);\n\n\tvec2 dHdxy = vec2(Hr - Hl, Hu - Hd);\n\tfloat fBlend = clamp(1.0 - textureQueryLOD(ima, texco.xy).x, 0.0, 1.0);\n\tif (fBlend != 0.0) {\n\t\t// the derivative of the bicubic sampling of level 0\n\t\tivec2 vDim;\n\t\tvDim = textureSize(ima, 0);\n\n\t\t// taking the fract part of the texture coordinate is a hardcoded wrap mode.\n\t\t// this is acceptable as textures use wrap mode exclusively in 3D view elsewhere in blender.\n\t\t// this is done so that we can still get a valid texel with uvs outside the 0,1 range\n\t\t// by texelFetch below, as coordinates are clamped when using this function.\n\t\tvec2 fTexLoc = vDim * fract(texco.xy) - vec2(0.5, 0.5);\n\t\tivec2 iTexLoc = ivec2(floor(fTexLoc));\n\t\tvec2 t = clamp(fTexLoc - iTexLoc, 0.0, 1.0);        // sat just to be pedantic\n\n/*******************************************************************************************\n * This block will replace the one below when one channel textures are properly supported. *\n *******************************************************************************************\n\t\tvec4 vSamplesUL = textureGather(ima, (iTexLoc+ivec2(-1,-1) + vec2(0.5,0.5))/vDim);\n\t\tvec4 vSamplesUR = textureGather(ima, (iTexLoc+ivec2(1,-1) + vec2(0.5,0.5))/vDim);\n\t\tvec4 vSamplesLL = textureGather(ima, (iTexLoc+ivec2(-1,1) + vec2(0.5,0.5))/vDim);\n\t\tvec4 vSamplesLR = textureGather(ima, (iTexLoc+ivec2(1,1) + vec2(0.5,0.5))/vDim);\n\n\t\tmat4 H = mat4(vSamplesUL.w, vSamplesUL.x, vSamplesLL.w, vSamplesLL.x,\n\t\t            vSamplesUL.z, vSamplesUL.y, vSamplesLL.z, vSamplesLL.y,\n\t\t            vSamplesUR.w, vSamplesUR.x, vSamplesLR.w, vSamplesLR.x,\n\t\t            vSamplesUR.z, vSamplesUR.y, vSamplesLR.z, vSamplesLR.y);\n */\n\t\tivec2 iTexLocMod = iTexLoc + ivec2(-1, -1);\n\n\t\tmat4 H;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tivec2 iTexTmp = iTexLocMod + ivec2(i, j);\n\n\t\t\t\t// wrap texture coordinates manually for texelFetch to work on uvs oitside the 0,1 range.\n\t\t\t\t// this is guaranteed to work since we take the fractional part of the uv above.\n\t\t\t\tiTexTmp.x = (iTexTmp.x < 0) ? iTexTmp.x + vDim.x : ((iTexTmp.x >= vDim.x) ? iTexTmp.x - vDim.x : iTexTmp.x);\n\t\t\t\tiTexTmp.y = (iTexTmp.y < 0) ? iTexTmp.y + vDim.y : ((iTexTmp.y >= vDim.y) ? iTexTmp.y - vDim.y : iTexTmp.y);\n\n\t\t\t\trgbtobw(texelFetch(ima, iTexTmp, 0), H[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tfloat x = t.x, y = t.y;\n\t\tfloat x2 = x * x, x3 = x2 * x, y2 = y * y, y3 = y2 * y;\n\n\t\tvec4 X  = vec4(-0.5 * (x3 + x) + x2,    1.5 * x3 - 2.5 * x2 + 1, -1.5 * x3 + 2 * x2 + 0.5 * x, 0.5 * (x3 - x2));\n\t\tvec4 Y  = vec4(-0.5 * (y3 + y) + y2,    1.5 * y3 - 2.5 * y2 + 1, -1.5 * y3 + 2 * y2 + 0.5 * y, 0.5 * (y3 - y2));\n\t\tvec4 dX = vec4(-1.5 * x2 + 2 * x - 0.5, 4.5 * x2 - 5 * x,        -4.5 * x2 + 4 * x + 0.5,      1.5 * x2 - x);\n\t\tvec4 dY = vec4(-1.5 * y2 + 2 * y - 0.5, 4.5 * y2 - 5 * y,        -4.5 * y2 + 4 * y + 0.5,      1.5 * y2 - y);\n\n\t\t// complete derivative in normalized coordinates (mul by vDim)\n\t\tvec2 dHdST = vDim * vec2(dot(Y, H * dX), dot(dY, H * X));\n\n\t\t// transform derivative to screen-space\n\t\tvec2 dHdxy_bicubic = vec2(dHdST.x * TexDx.x + dHdST.y * TexDx.y,\n\t\t                          dHdST.x * TexDy.x + dHdST.y * TexDy.y);\n\n\t\t// blend between the two\n\t\tdHdxy = dHdxy * (1 - fBlend) + dHdxy_bicubic * fBlend;\n\t}\n\n\tdBs = hScale * dHdxy.x;\n\tdBt = hScale * dHdxy.y;\n}\n\n#endif\n\nvoid mtex_bump_tap5(\n        vec3 texco, sampler2D ima, float hScale,\n        out float dBs, out float dBt)\n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec2 STc = texco.xy;\n\tvec2 STl = texco.xy - 0.5 * TexDx;\n\tvec2 STr = texco.xy + 0.5 * TexDx;\n\tvec2 STd = texco.xy - 0.5 * TexDy;\n\tvec2 STu = texco.xy + 0.5 * TexDy;\n\n\tfloat Hc, Hl, Hr, Hd, Hu;\n\trgbtobw(texture2D(ima, STc), Hc);\n\trgbtobw(texture2D(ima, STl), Hl);\n\trgbtobw(texture2D(ima, STr), Hr);\n\trgbtobw(texture2D(ima, STd), Hd);\n\trgbtobw(texture2D(ima, STu), Hu);\n\n\tdBs = hScale * (Hr - Hl);\n\tdBt = hScale * (Hu - Hd);\n}\n\nvoid mtex_bump_deriv(\n        vec3 texco, sampler2D ima, float ima_x, float ima_y, float hScale,\n        out float dBs, out float dBt)\n{\n\tfloat s = 1.0;      // negate this if flipped texture coordinate\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\t// this variant using a derivative map is described here\n\t// http://mmikkelsen3d.blogspot.com/2011/07/derivative-maps.html\n\tvec2 dim = vec2(ima_x, ima_y);\n\tvec2 dBduv = hScale * dim * (2.0 * texture2D(ima, texco.xy).xy - 1.0);\n\n\tdBs = dBduv.x * TexDx.x + s * dBduv.y * TexDx.y;\n\tdBt = dBduv.x * TexDy.x + s * dBduv.y * TexDy.y;\n}\n\nvoid mtex_bump_apply(\n        float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2, vec3 vNacc_in,\n        out vec3 vNacc_out, out vec3 perturbed_norm)\n{\n\tvec3 vSurfGrad = sign(fDet) * (dBs * vR1 + dBt * vR2);\n\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize(vNacc_out);\n}\n\nvoid mtex_bump_apply_texspace(\n        float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2,\n        sampler2D ima, vec3 texco, float ima_x, float ima_y, vec3 vNacc_in,\n        out vec3 vNacc_out, out vec3 perturbed_norm)\n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec3 vSurfGrad = sign(fDet) * (\n\t        dBs / length(vec2(ima_x * TexDx.x, ima_y * TexDx.y)) * vR1 +\n\t        dBt / length(vec2(ima_x * TexDy.x, ima_y * TexDy.y)) * vR2);\n\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize(vNacc_out);\n}\n\nvoid mtex_negate_texnormal(vec3 normal, out vec3 outnormal)\n{\n\toutnormal = vec3(-normal.x, -normal.y, normal.z);\n}\n\nvoid mtex_nspace_tangent(vec4 tangent, vec3 normal, vec3 texnormal, out vec3 outnormal)\n{\n\tvec3 B = tangent.w * cross(normal, tangent.xyz);\n\n\toutnormal = texnormal.x * tangent.xyz + texnormal.y * B + texnormal.z * normal;\n\toutnormal = normalize(outnormal);\n}\n\nvoid mtex_nspace_world(mat4 viewmat, vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize((viewmat * vec4(texnormal, 0.0)).xyz);\n}\n\nvoid mtex_nspace_object(vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize(mat3(1) * texnormal);\n}\n\nvoid mtex_blend_normal(float norfac, vec3 normal, vec3 newnormal, out vec3 outnormal)\n{\n\toutnormal = (1.0 - norfac) * normal + norfac * newnormal;\n\toutnormal = normalize(outnormal);\n}\n\n/******* MATERIAL *********/\n\nvoid lamp_visibility_sun_hemi(vec3 lampvec, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = lampvec;\n\tdist = 1.0;\n\tvisifac = 1.0;\n}\n\nvoid lamp_visibility_other(vec3 co, vec3 lampco, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = co - lampco;\n\tdist = length(lv);\n\tlv = normalize(lv);\n\tvisifac = 1.0;\n}\n\nvoid lamp_falloff_invlinear(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist / (lampdist + dist);\n}\n\nvoid lamp_falloff_invsquare(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist / (lampdist + dist * dist);\n}\n\nvoid lamp_falloff_sliders(float lampdist, float ld1, float ld2, float dist, out float visifac)\n{\n\tfloat lampdistkw = lampdist * lampdist;\n\n\tvisifac = lampdist / (lampdist + ld1 * dist);\n\tvisifac *= lampdistkw / (lampdistkw + ld2 * dist * dist);\n}\n\nvoid lamp_falloff_invcoefficients(float coeff_const, float coeff_lin, float coeff_quad, float dist, out float visifac)\n{\n\tvec3 coeff = vec3(coeff_const, coeff_lin, coeff_quad);\n\tvec3 d_coeff = vec3(1.0, dist, dist * dist);\n\tfloat visifac_r = dot(coeff, d_coeff);\n\tif (visifac_r > 0.0)\n\t\tvisifac = 1.0 / visifac_r;\n\telse\n\t\tvisifac = 0.0;\n}\n\nvoid lamp_falloff_curve(float lampdist, sampler2D curvemap, float dist, out float visifac)\n{\n\tvisifac = texture2D(curvemap, vec2(dist / lampdist, 0.0)).x;\n}\n\nvoid lamp_visibility_sphere(float lampdist, float dist, float visifac, out float outvisifac)\n{\n\tfloat t = lampdist - dist;\n\n\toutvisifac = visifac * max(t, 0.0) / lampdist;\n}\n\nvoid lamp_visibility_spot_square(vec3 lampvec, mat4 lampimat, vec2 scale, vec3 lv, out float inpr)\n{\n\tif (dot(lv, lampvec) > 0.0) {\n\t\tvec3 lvrot = (lampimat * vec4(lv, 0.0)).xyz;\n\t\t/* without clever non-uniform scale, we could do: */\n\t\t// float x = max(abs(lvrot.x / lvrot.z), abs(lvrot.y / lvrot.z));\n\t\tfloat x = max(abs((lvrot.x / scale.x) / lvrot.z), abs((lvrot.y / scale.y) / lvrot.z));\n\n\t\tinpr = 1.0 / sqrt(1.0 + x * x);\n\t}\n\telse\n\t\tinpr = 0.0;\n}\n\nvoid lamp_visibility_spot_circle(vec3 lampvec, mat4 lampimat, vec2 scale, vec3 lv, out float inpr)\n{\n\t/* without clever non-uniform scale, we could do: */\n\t// inpr = dot(lv, lampvec);\n\tif (dot(lv, lampvec) > 0.0) {\n\t\tvec3 lvrot = (lampimat * vec4(lv, 0.0)).xyz;\n\t\tfloat x = abs(lvrot.x / lvrot.z);\n\t\tfloat y = abs(lvrot.y / lvrot.z);\n\n\t\tfloat ellipse = abs((x * x) / (scale.x * scale.x) + (y * y) / (scale.y * scale.y));\n\n\t\tinpr = 1.0 / sqrt(1.0 + ellipse);\n\t}\n\telse\n\t\tinpr = 0.0;\n}\n\nvoid lamp_visibility_spot(float spotsi, float spotbl, float inpr, float visifac, out float outvisifac)\n{\n\tfloat t = spotsi;\n\n\tif (inpr <= t) {\n\t\toutvisifac = 0.0;\n\t}\n\telse {\n\t\tt = inpr - t;\n\n\t\t/* soft area */\n\t\tif (spotbl != 0.0)\n\t\t\tinpr *= smoothstep(0.0, 1.0, t / spotbl);\n\n\t\toutvisifac = visifac * inpr;\n\t}\n}\n\nvoid lamp_visibility_clamp(float visifac, out float outvisifac)\n{\n\toutvisifac = (visifac < 0.001) ? 0.0 : visifac;\n}\n\nvoid world_paper_view(vec3 vec, out vec3 outvec)\n{\n\tvec3 nvec = normalize(vec);\n\toutvec = (0.0 == 0.0) ? vec3(nvec.x, 0.0, nvec.y) : vec3(0.0, 0.0, -1.0);\n}\n\nvoid world_zen_mapping(vec3 view, float zenup, float zendown, out float zenfac)\n{\n\tif (view.z >= 0.0)\n\t\tzenfac = zenup;\n\telse\n\t\tzenfac = zendown;\n}\n\nvoid world_blend_paper_real(vec3 vec, out float blend)\n{\n\tblend = abs(vec.y);\n}\n\nvoid world_blend_paper(vec3 vec, out float blend)\n{\n\tblend = (vec.y + 1.0) * 0.5;\n}\n\nvoid world_blend_real(vec3 vec, out float blend)\n{\n\tblend = abs(normalize(vec).z);\n}\n\nvoid world_blend(vec3 vec, out float blend)\n{\n\tblend = (normalize(vec).z + 1.0) * 0.5;\n}\n\nvoid shade_view(vec3 co, out vec3 view)\n{\n\t/* handle perspective/orthographic */\n\tview = (0.0 == 0.0) ? normalize(co) : vec3(0.0, 0.0, -1.0);\n}\n\nvoid shade_tangent_v(vec3 lv, vec3 tang, out vec3 vn)\n{\n\tvec3 c = cross(lv, tang);\n\tvec3 vnor = cross(c, tang);\n\n\tvn = -normalize(vnor);\n}\n\nvoid shade_inp(vec3 vn, vec3 lv, out float inp)\n{\n\tinp = dot(vn, lv);\n}\n\nvoid shade_is_no_diffuse(out float is)\n{\n\tis = 0.0;\n}\n\nvoid shade_is_hemi(float inp, out float is)\n{\n\tis = 0.5 * inp + 0.5;\n}\n\nfloat area_lamp_energy(mat4 area, vec3 co, vec3 vn)\n{\n\tvec3 vec[4], c[4];\n\tfloat rad[4];float fac;\n\n\tvec[0] = normalize(co - area[0].xyz);\n\tvec[1] = normalize(co - area[1].xyz);\n\tvec[2] = normalize(co - area[2].xyz);\n\tvec[3] = normalize(co - area[3].xyz);\n\n\tc[0] = normalize(cross(vec[0], vec[1]));\n\tc[1] = normalize(cross(vec[1], vec[2]));\n\tc[2] = normalize(cross(vec[2], vec[3]));\n\tc[3] = normalize(cross(vec[3], vec[0]));\n\n\trad[0] = acos(dot(vec[0], vec[1]));\n\trad[1] = acos(dot(vec[1], vec[2]));\n\trad[2] = acos(dot(vec[2], vec[3]));\n\trad[3] = acos(dot(vec[3], vec[0]));\n\n\tfac =  rad[0] * dot(vn, c[0]);\n\tfac += rad[1] * dot(vn, c[1]);\n\tfac += rad[2] * dot(vn, c[2]);\n\tfac += rad[3] * dot(vn, c[3]);\n\n\treturn max(fac, 0.0);\n}\n\nvoid shade_inp_area(\n        vec3 position, vec3 lampco, vec3 lampvec, vec3 vn, mat4 area, float areasize, float k,\n        out float inp)\n{\n\tvec3 co = position;\n\tvec3 vec = co - lampco;\n\n\tif (dot(vec, lampvec) < 0.0) {\n\t\tinp = 0.0;\n\t}\n\telse {\n\t\tfloat intens = area_lamp_energy(area, co, vn);\n\n\t\tinp = pow(intens * areasize, k);\n\t}\n}\n\nvoid shade_diffuse_oren_nayer(float nl, vec3 n, vec3 l, vec3 v, float rough, out float is)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = max(dot(n, h), 0.0);\n\tfloat nv = max(dot(n, v), 0.0);\n\tfloat realnl = dot(n, l);\n\n\tif (realnl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse if (nl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat vh = max(dot(v, h), 0.0);\n\t\tfloat Lit_A = acos(realnl);\n\t\tfloat View_A = acos(nv);\n\n\t\tvec3 Lit_B = normalize(l - realnl * n);\n\t\tvec3 View_B = normalize(v - nv * n);\n\n\t\tfloat t = max(dot(Lit_B, View_B), 0.0);\n\n\t\tfloat a, b;\n\n\t\tif (Lit_A > View_A) {\n\t\t\ta = Lit_A;\n\t\t\tb = View_A;\n\t\t}\n\t\telse {\n\t\t\ta = View_A;\n\t\t\tb = Lit_A;\n\t\t}\n\n\t\tfloat A = 1.0 - (0.5 * ((rough * rough) / ((rough * rough) + 0.33)));\n\t\tfloat B = 0.45 * ((rough * rough) / ((rough * rough) + 0.09));\n\n\t\tb *= 0.95;\n\t\tis = nl * (A + (B * t * sin(a) * tan(b)));\n\t}\n}\n\nvoid shade_diffuse_toon(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float is)\n{\n\tfloat rslt = dot(n, l);\n\tfloat ang = acos(rslt);\n\n\tif (ang < size) is = 1.0;\n\telse if (ang > (size + tsmooth) || tsmooth == 0.0) is = 0.0;\n\telse is = 1.0 - ((ang - size) / tsmooth);\n}\n\nvoid shade_diffuse_minnaert(float nl, vec3 n, vec3 v, float darkness, out float is)\n{\n\tif (nl <= 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\n\t\tif (darkness <= 1.0)\n\t\t\tis = nl * pow(max(nv * nl, 0.1), darkness - 1.0);\n\t\telse\n\t\t\tis = nl * pow(1.0001 - nv, darkness - 1.0);\n\t}\n}\n\nfloat fresnel_fac(vec3 view, vec3 vn, float grad, float fac)\n{\n\tfloat t1, t2;\n\tfloat ffac;\n\n\tif (fac == 0.0) {\n\t\tffac = 1.0;\n\t}\n\telse {\n\t\tt1 = dot(view, vn);\n\t\tif (t1 > 0.0) t2 = 1.0 + t1;\n\t\telse t2 = 1.0 - t1;\n\n\t\tt2 = grad + (1.0 - grad) * pow(t2, fac);\n\n\t\tif (t2 < 0.0) ffac = 0.0;\n\t\telse if (t2 > 1.0) ffac = 1.0;\n\t\telse ffac = t2;\n\t}\n\n\treturn ffac;\n}\n\nvoid shade_diffuse_fresnel(vec3 vn, vec3 lv, vec3 view, float fac_i, float fac, out float is)\n{\n\tis = fresnel_fac(lv, vn, fac_i, fac);\n}\n\nvoid shade_cubic(float is, out float outis)\n{\n\tif (is > 0.0 && is < 1.0)\n\t\toutis = smoothstep(0.0, 1.0, is);\n\telse\n\t\toutis = is;\n}\n\nvoid shade_visifac(float i, float visifac, float refl, out float outi)\n{\n\t/*if (i > 0.0)*/\n\touti = max(i * visifac * refl, 0.0);\n\t/*else\n\t    outi = i;*/\n}\n\nvoid shade_tangent_v_spec(vec3 tang, out vec3 vn)\n{\n\tvn = tang;\n}\n\nvoid shade_add_to_diffuse(float i, vec3 lampcol, vec3 col, out vec3 outcol)\n{\n\tif (i > 0.0)\n\t\toutcol = i * lampcol * col;\n\telse\n\t\toutcol = vec3(0.0, 0.0, 0.0);\n}\n\nvoid shade_hemi_spec(vec3 vn, vec3 lv, vec3 view, float spec, float hard, float visifac, out float t)\n{\n\tlv += view;\n\tlv = normalize(lv);\n\n\tt = dot(vn, lv);\n\tt = 0.5 * t + 0.5;\n\n\tt = visifac * spec * pow(t, hard);\n}\n\nvoid shade_phong_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = max(dot(h, n), 0.0);\n\n\tspecfac = pow(rslt, hard);\n}\n\nvoid shade_cooktorr_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = dot(n, h);\n\n\tif (nh < 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\t\tfloat i = pow(nh, hard);\n\n\t\ti = i / (0.1 + nv);\n\t\tspecfac = i;\n\t}\n}\n\nvoid shade_blinn_spec(vec3 n, vec3 l, vec3 v, float refrac, float spec_power, out float specfac)\n{\n\tif (refrac < 1.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse if (spec_power == 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tif (spec_power < 100.0)\n\t\t\tspec_power = sqrt(1.0 / spec_power);\n\t\telse\n\t\t\tspec_power = 10.0 / spec_power;\n\n\t\tvec3 h = normalize(v + l);\n\t\tfloat nh = dot(n, h);\n\t\tif (nh < 0.0) {\n\t\t\tspecfac = 0.0;\n\t\t}\n\t\telse {\n\t\t\tfloat nv = max(dot(n, v), 0.01);\n\t\t\tfloat nl = dot(n, l);\n\t\t\tif (nl <= 0.01) {\n\t\t\t\tspecfac = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfloat vh = max(dot(v, h), 0.01);\n\n\t\t\t\tfloat a = 1.0;\n\t\t\t\tfloat b = (2.0 * nh * nv) / vh;\n\t\t\t\tfloat c = (2.0 * nh * nl) / vh;\n\n\t\t\t\tfloat g = 0.0;\n\n\t\t\t\tif (a < b && a < c) g = a;\n\t\t\t\telse if (b < a && b < c) g = b;\n\t\t\t\telse if (c < a && c < b) g = c;\n\n\t\t\t\tfloat p = sqrt(((refrac * refrac) + (vh * vh) - 1.0));\n\t\t\t\tfloat f = ((((p - vh) * (p - vh)) / ((p + vh) * (p + vh))) *\n\t\t\t\t           (1.0 + ((((vh * (p + vh)) - 1.0) * ((vh * (p + vh)) - 1.0)) /\n\t\t\t\t                   (((vh * (p - vh)) + 1.0) * ((vh * (p - vh)) + 1.0)))));\n\t\t\t\tfloat ang = acos(nh);\n\n\t\t\t\tspecfac = max(f * g * exp_blender((-(ang * ang) / (2.0 * spec_power * spec_power))), 0.0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shade_wardiso_spec(vec3 n, vec3 l, vec3 v, float rms, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat nh = max(dot(n, h), 0.001);\n\tfloat nv = max(dot(n, v), 0.001);\n\tfloat nl = max(dot(n, l), 0.001);\n\tfloat angle = tan(acos(nh));\n\tfloat alpha = max(rms, 0.001);\n\n\tspecfac = nl * (1.0 / (4.0 * M_PI * alpha * alpha)) * (exp_blender(-(angle * angle) / (alpha * alpha)) / (sqrt(nv * nl)));\n}\n\nvoid shade_toon_spec(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = dot(h, n);\n\tfloat ang = acos(rslt);\n\n\tif (ang < size) rslt = 1.0;\n\telse if (ang >= (size + tsmooth) || tsmooth == 0.0) rslt = 0.0;\n\telse rslt = 1.0 - ((ang - size) / tsmooth);\n\n\tspecfac = rslt;\n}\n\nvoid shade_spec_area_inp(float specfac, float inp, out float outspecfac)\n{\n\toutspecfac = specfac * inp;\n}\n\nvoid shade_spec_t(float shadfac, float spec, float visifac, float specfac, out float t)\n{\n\tt = shadfac * spec * visifac * specfac;\n}\n\nvoid shade_add_spec(float t, vec3 lampcol, vec3 speccol, out vec3 outcol)\n{\n\toutcol = t * lampcol * speccol;\n}\n\nvoid shade_add_mirror(vec3 mir, vec4 refcol, vec3 combined, out vec3 result)\n{\n\tresult = mir * refcol.gba + (vec3(1.0) - mir * refcol.rrr) * combined;\n}\n\nvoid alpha_spec_correction(vec3 spec, float spectra, float alpha, out float outalpha)\n{\n\tif (spectra > 0.0) {\n\t\tfloat t = clamp(max(max(spec.r, spec.g), spec.b) * spectra, 0.0, 1.0);\n\t\toutalpha = (1.0 - t) * alpha + t;\n\t}\n\telse {\n\t\toutalpha = alpha;\n\t}\n}\n\nvoid shade_add(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + col2;\n}\n\nvoid shade_madd(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + col1 * col2;\n}\n\nvoid shade_add_clamped(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + max(col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_madd_clamped(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + max(col1 * col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid env_apply(vec4 col, vec3 hor, vec3 zen, vec4 f, mat4 vm, vec3 vn, out vec4 outcol)\n{\n\tvec3 vv = normalize(vm[2].xyz);\n\tfloat skyfac = 0.5 * (1.0 + dot(vn, -vv));\n\toutcol = col + f * vec4(mix(hor, zen, skyfac), 0);\n}\n\nvoid shade_maddf(vec4 col, float f, vec4 col1, out vec4 outcol)\n{\n\toutcol = col + f * col1;\n}\n\nvoid shade_mul(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 * col2;\n}\n\nvoid shade_mul_value(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol = col * fac;\n}\n\nvoid shade_mul_value_v3(float fac, vec3 col, out vec3 outcol)\n{\n\toutcol = col * fac;\n}\n\nvoid shade_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb * obcol.rgb, col.a);\n}\n\nvoid ramp_rgbtobw(vec3 color, out float outval)\n{\n\toutval = color.r * 0.3 + color.g * 0.58 + color.b * 0.12;\n}\n\nvoid shade_only_shadow(float i, float shadfac, float energy, vec3 shadcol, out vec3 outshadrgb)\n{\n\toutshadrgb = i * energy * (1.0 - shadfac) * (vec3(1.0) - shadcol);\n}\n\nvoid shade_only_shadow_diffuse(vec3 shadrgb, vec3 rgb, vec4 diff, out vec4 outdiff)\n{\n\toutdiff = diff - vec4(rgb * shadrgb, 0.0);\n}\n\nvoid shade_only_shadow_specular(vec3 shadrgb, vec3 specrgb, vec4 spec, out vec4 outspec)\n{\n\toutspec = spec - vec4(specrgb * shadrgb, 0.0);\n}\n\nvoid shade_clamp_positive(vec4 col, out vec4 outcol)\n{\n\toutcol = max(col, vec4(0.0));\n}\n\nvoid test_shadowbuf(\n        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float inp,\n        out float result)\n{\n\tif (inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat * vec4(rco, 1.0);\n\n\t\t//float bias = (1.5 - inp*inp)*shadowbias;\n\t\tco.z -= shadowbias * co.w;\n\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x / co.w < 1.0 && co.y > 0.0 && co.y / co.w < 1.0)\n\t\t\tresult = step(co.z,texture2D(shadowmap, co.xy).x);\n\t\telse\n\t\t\tresult = 1.0;\n\t}\n}\n\nvoid test_shadowbuf_vsm(\n        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, float inp,\n        out float result)\n{\n\tif (inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat * vec4(rco, 1.0);\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x / co.w < 1.0 && co.y > 0.0 && co.y / co.w < 1.0) {\n\t\t\tvec2 moments = texture2DProj(shadowmap, co).rg;\n\t\t\tfloat dist = co.z / co.w;\n\t\t\tfloat p = 0.0;\n\n\t\t\tif (dist <= moments.x)\n\t\t\t\tp = 1.0;\n\n\t\t\tfloat variance = moments.y - (moments.x * moments.x);\n\t\t\tvariance = max(variance, shadowbias / 10.0);\n\n\t\t\tfloat d = moments.x - dist;\n\t\t\tfloat p_max = variance / (variance + d * d);\n\n\t\t\t// Now reduce light-bleeding by removing the [0, x] tail and linearly rescaling (x, 1]\n\t\t\tp_max = clamp((p_max - bleedbias) / (1.0 - bleedbias), 0.0, 1.0);\n\n\t\t\tresult = max(p, p_max);\n\t\t}\n\t\telse {\n\t\t\tresult = 1.0;\n\t\t}\n\t}\n}\n\nvoid shadows_only(\n        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat,\n        float shadowbias, vec3 shadowcolor, float inp,\n        out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif (inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf(rco, shadowmap, shadowpersmat, shadowbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shadows_only_vsm(\n        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat,\n        float shadowbias, float bleedbias, vec3 shadowcolor, float inp,\n        out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif (inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf_vsm(rco, shadowmap, shadowpersmat, shadowbias, bleedbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shade_light_texture(vec3 rco, sampler2D cookie, mat4 shadowpersmat, out vec4 result)\n{\n\n\tvec4 co = shadowpersmat * vec4(rco, 1.0);\n\n\tresult = texture2DProj(cookie, co);\n}\n\nvoid shade_exposure_correct(vec3 col, float linfac, float logfac, out vec3 outcol)\n{\n\toutcol = linfac * (1.0 - exp(col * logfac));\n}\n\nvoid shade_mist_factor(\n        vec3 co, float enable, float miststa, float mistdist, float misttype, float misi,\n        out float outfac)\n{\n\tif (enable == 1.0) {\n\t\tfloat fac, zcor;\n\n\t\tzcor = (0.0 == 0.0) ? length(co) : -co[2];\n\n\t\tfac = clamp((zcor - miststa) / mistdist, 0.0, 1.0);\n\t\tif (misttype == 0.0) fac *= fac;\n\t\telse if (misttype == 1.0) ;\n\t\telse fac = sqrt(fac);\n\n\t\toutfac = 1.0 - (1.0 - fac) * (1.0 - misi);\n\t}\n\telse {\n\t\toutfac = 0.0;\n\t}\n}\n\nvoid shade_world_mix(vec3 hor, vec4 col, out vec4 outcol)\n{\n\tfloat fac = clamp(col.a, 0.0, 1.0);\n\toutcol = vec4(mix(hor, col.rgb, fac), col.a);\n}\n\nvoid shade_alpha_opaque(vec4 col, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, 1.0);\n}\n\nvoid shade_alpha_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, col.a * obcol.a);\n}\n\n/*********** NEW SHADER UTILITIES **************/\n\nfloat fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta)\n{\n\t/* compute fresnel reflectance without explicitly computing\n\t * the refracted direction */\n\tfloat c = abs(dot(Incoming, Normal));\n\tfloat g = eta * eta - 1.0 + c * c;\n\tfloat result;\n\n\tif (g > 0.0) {\n\t\tg = sqrt(g);\n\t\tfloat A = (g - c) / (g + c);\n\t\tfloat B = (c * (g + c) - 1.0) / (c * (g - c) + 1.0);\n\t\tresult = 0.5 * A * A * (1.0 + B * B);\n\t}\n\telse {\n\t\tresult = 1.0;  /* TIR (no refracted component) */\n\t}\n\n\treturn result;\n}\n\nfloat hypot(float x, float y)\n{\n\treturn sqrt(x * x + y * y);\n}\n\nvoid generated_from_orco(vec3 orco, out vec3 generated)\n{\n\tgenerated = orco * 0.5 + vec3(0.5);\n}\n\nint floor_to_int(float x)\n{\n\treturn int(floor(x));\n}\n\nint quick_floor(float x)\n{\n\treturn int(x) - ((x < 0.0) ? 1 : 0);\n}\n\n#ifdef BIT_OPERATIONS\n#endif\n\nfloat floorfrac(float x, out int i)\n{\n\ti = floor_to_int(x);\n\treturn x - float(i);\n}\n\n/*********** NEW SHADER NODES ***************/\n\n#define NUM_LIGHTS 3\n\n/* bsdfs */\n\nvoid node_bsdf_diffuse(vec4 color, float roughness, vec3 N, out vec4 result)\n{\n\t/* ambient light */\n\tvec3 L = vec3(0.2);\n\n\t/* directional lights */\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 light_position = vec3(0,0,0).xyz;\n\t\tvec3 light_diffuse = vec3(0,0,0).rgb;\n\n\t\tfloat bsdf = max(dot(N, light_position), 0.0);\n\t\tL += light_diffuse * bsdf;\n\t}\n\n\tresult = vec4(L * color.rgb, 1.0);\n}\n\nvoid node_bsdf_glossy(vec4 color, float roughness, vec3 N, out vec4 result)\n{\n\t/* ambient light */\n\tvec3 L = vec3(0.2);\n\n\t/* directional lights */\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 light_position = vec3(0,0,0).xyz;\n\t\tvec3 H = vec3(0,0,0).xyz;\n\t\tvec3 light_diffuse = vec3(0,0,0).rgb;\n\t\tvec3 light_specular = vec3(0,0,0).rgb;\n\n\t\t/* we mix in some diffuse so low roughness still shows up */\n\t\tfloat bsdf = 0.5 * pow(max(dot(N, H), 0.0), 1.0 / roughness);\n\t\tbsdf += 0.5 * max(dot(N, light_position), 0.0);\n\t\tL += light_specular * bsdf;\n\t}\n\n\tresult = vec4(L * color.rgb, 1.0);\n}\n\nvoid node_bsdf_anisotropic(\n        vec4 color, float roughness, float anisotropy, float rotation, vec3 N, vec3 T,\n        out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_glass(vec4 color, float roughness, float ior, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_toon(vec4 color, float size, float tsmooth, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_translucent(vec4 color, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_transparent(vec4 color, out vec4 result)\n{\n\t/* this isn't right */\n\tresult.r = color.r;\n\tresult.g = color.g;\n\tresult.b = color.b;\n\tresult.a = 0.0;\n}\n\nvoid node_bsdf_velvet(vec4 color, float sigma, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_subsurface_scattering(\n        vec4 color, float scale, vec3 radius, float sharpen, float texture_blur, vec3 N,\n        out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_hair(vec4 color, float offset, float roughnessu, float roughnessv, vec3 tangent, out vec4 result)\n{\n\tresult = color;\n}\n\nvoid node_bsdf_refraction(vec4 color, float roughness, float ior, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_ambient_occlusion(vec4 color, out vec4 result)\n{\n\tresult = color;\n}\n\n/* emission */\n\nvoid node_emission(vec4 color, float strength, vec3 N, out vec4 result)\n{\n\tresult = color * strength;\n}\n\n/* background */\n\nvoid background_transform_to_world(vec3 viewvec, out vec3 worldvec)\n{\n\tvec4 v = (0.0 == 0.0) ? vec4(viewvec, 1.0) : vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 co_homogenous = (mat4(1) * v);\n\n\tvec4 co = vec4(co_homogenous.xyz / co_homogenous.w, 0.0);\n\tworldvec = (mat4(1) * co).xyz;\n}\n\nvoid node_background(vec4 color, float strength, vec3 N, out vec4 result)\n{\n\tresult = color * strength;\n}\n\n/* closures */\n\nvoid node_mix_shader(float fac, vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = mix(shader1, shader2, fac);\n}\n\nvoid node_add_shader(vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = shader1 + shader2;\n}\n\n/* fresnel */\n\nvoid node_fresnel(float ior, vec3 N, vec3 I, out float result)\n{\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (0.0 == 0.0) ? normalize(I) : vec3(0.0, 0.0, -1.0);\n\n\tfloat eta = max(ior, 0.00001);\n\tresult = fresnel_dielectric(I_view, N, (gl_FrontFacing) ? eta : 1.0 / eta);\n}\n\n/* layer_weight */\n\nvoid node_layer_weight(float blend, vec3 N, vec3 I, out float fresnel, out float facing)\n{\n\t/* fresnel */\n\tfloat eta = max(1.0 - blend, 0.00001);\n\tvec3 I_view = (0.0 == 0.0) ? normalize(I) : vec3(0.0, 0.0, -1.0);\n\n\tfresnel = fresnel_dielectric(I_view, N, (gl_FrontFacing) ? 1.0 / eta : eta);\n\n\t/* facing */\n\tfacing = abs(dot(I_view, N));\n\tif (blend != 0.5) {\n\t\tblend = clamp(blend, 0.0, 0.99999);\n\t\tblend = (blend < 0.5) ? 2.0 * blend : 0.5 / (1.0 - blend);\n\t\tfacing = pow(facing, blend);\n\t}\n\tfacing = 1.0 - facing;\n}\n\n/* gamma */\n\nvoid node_gamma(vec4 col, float gamma, out vec4 outcol)\n{\n\toutcol = col;\n\n\tif (col.r > 0.0)\n\t\toutcol.r = compatible_pow(col.r, gamma);\n\tif (col.g > 0.0)\n\t\toutcol.g = compatible_pow(col.g, gamma);\n\tif (col.b > 0.0)\n\t\toutcol.b = compatible_pow(col.b, gamma);\n}\n\n/* geometry */\n\nvoid node_attribute(vec3 attr, out vec4 outcol, out vec3 outvec, out float outf)\n{\n\toutcol = vec4(attr, 1.0);\n\toutvec = attr;\n\toutf = (attr.x + attr.y + attr.z) / 3.0;\n}\n\nvoid node_uvmap(vec3 attr_uv, out vec3 outvec)\n{\n\toutvec = attr_uv;\n}\n\nvoid node_geometry(\n        vec3 I, vec3 N, mat4 toworld,\n        out vec3 position, out vec3 normal, out vec3 tangent,\n        out vec3 true_normal, out vec3 incoming, out vec3 parametric,\n        out float backfacing, out float pointiness)\n{\n\tposition = (toworld * vec4(I, 1.0)).xyz;\n\tnormal = (toworld * vec4(N, 0.0)).xyz;\n\ttangent = vec3(0.0);\n\ttrue_normal = normal;\n\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (0.0 == 0.0) ? normalize(I) : vec3(0.0, 0.0, -1.0);\n\tincoming = -(toworld * vec4(I_view, 0.0)).xyz;\n\n\tparametric = vec3(0.0);\n\tbackfacing = (gl_FrontFacing) ? 0.0 : 1.0;\n\tpointiness = 0.5;\n}\n\nvoid node_tex_coord(\n        vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat, vec4 camerafac,\n        vec3 attr_orco, vec3 attr_uv,\n        out vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\n        out vec3 camera, out vec3 window, out vec3 reflection)\n{\n\tgenerated = attr_orco * 0.5 + vec3(0.5);\n\tnormal = normalize((obinvmat * (viewinvmat * vec4(N, 0.0))).xyz);\n\tuv = attr_uv;\n\tobject = (obinvmat * (viewinvmat * vec4(I, 1.0))).xyz;\n\tcamera = vec3(I.xy, -I.z);\n\tvec4 projvec = mat4(1) * vec4(I, 1.0);\n\twindow = vec3(mtex_2d_mapping(projvec.xyz / projvec.w).xy * camerafac.xy + camerafac.zw, 0.0);\n\n\tvec3 shade_I;\n\tshade_view(I, shade_I);\n\tvec3 view_reflection = reflect(shade_I, normalize(N));\n\treflection = (viewinvmat * vec4(view_reflection, 0.0)).xyz;\n}\n\nvoid node_tex_coord_background(\n        vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat, vec4 camerafac,\n        vec3 attr_orco, vec3 attr_uv,\n        out vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\n        out vec3 camera, out vec3 window, out vec3 reflection)\n{\n\tvec4 v = (0.0 == 0.0) ? vec4(I, 1.0) : vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 co_homogenous = (mat4(1) * v);\n\n\tvec4 co = vec4(co_homogenous.xyz / co_homogenous.w, 0.0);\n\n\tco = normalize(co);\n\tvec3 coords = (mat4(1) * co).xyz;\n\n\tgenerated = coords;\n\tnormal = -coords;\n\tuv = vec3(attr_uv.xy, 0.0);\n\tobject = coords;\n\n\tcamera = vec3(co.xy, -co.z);\n\twindow = (0.0 == 0.0) ?\n\t         vec3(mtex_2d_mapping(I).xy * camerafac.xy + camerafac.zw, 0.0) :\n\t         vec3(vec2(0.5) * camerafac.xy + camerafac.zw, 0.0);\n\n\treflection = -coords;\n}\n\n/* textures */\n\nfloat calc_gradient(vec3 p, int gradient_type)\n{\n\tfloat x, y, z;\n\tx = p.x;\n\ty = p.y;\n\tz = p.z;\n\tif (gradient_type == 0) {  /* linear */\n\t\treturn x;\n\t}\n\telse if (gradient_type == 1) {  /* quadratic */\n\t\tfloat r = max(x, 0.0);\n\t\treturn r * r;\n\t}\n\telse if (gradient_type == 2) {  /* easing */\n\t\tfloat r = min(max(x, 0.0), 1.0);\n\t\tfloat t = r * r;\n\t\treturn (3.0 * t - 2.0 * t * r);\n\t}\n\telse if (gradient_type == 3) {  /* diagonal */\n\t\treturn (x + y) * 0.5;\n\t}\n\telse if (gradient_type == 4) {  /* radial */\n\t\treturn atan(y, x) / (M_PI * 2.0) + 0.5;\n\t}\n\telse {\n\t\tfloat r = max(1.0 - sqrt(x * x + y * y + z * z), 0.0);\n\t\tif (gradient_type == 5) {  /* quadratic sphere */\n\t\t\treturn r * r;\n\t\t}\n\t\telse if (gradient_type == 6) {  /* sphere */\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0.0;\n}\n\nvoid node_tex_gradient(vec3 co, float gradient_type, out vec4 color, out float fac)\n{\n\tfloat f = calc_gradient(co, int(gradient_type));\n\tf = clamp(f, 0.0, 1.0);\n\n\tcolor = vec4(f, f, f, 1.0);\n\tfac = f;\n}\n\nvoid node_tex_checker(vec3 co, vec4 color1, vec4 color2, float scale, out vec4 color, out float fac)\n{\n\tvec3 p = co * scale;\n\n\t/* Prevent precision issues on unit coordinates. */\n\tp.x = (p.x + 0.000001) * 0.999999;\n\tp.y = (p.y + 0.000001) * 0.999999;\n\tp.z = (p.z + 0.000001) * 0.999999;\n\n\tint xi = int(abs(floor(p.x)));\n\tint yi = int(abs(floor(p.y)));\n\tint zi = int(abs(floor(p.z)));\n\n\tbool check = true;\n\n\tcolor = check ? color1 : color2;\n\tfac = check ? 1.0 : 0.0;\n}\n\n#ifdef BIT_OPERATIONS\nvec2 calc_brick_texture(vec3 p, float mortar_size, float bias,\n                        float brick_width, float row_height,\n                        float offset_amount, int offset_frequency,\n                        float squash_amount, int squash_frequency)\n{\n\tint bricknum, rownum;\n\tfloat offset = 0.0;\n\tfloat x, y;\n\n\trownum = floor_to_int(p.y / row_height);\n\n\tif (offset_frequency != 0 && squash_frequency != 0) {\n\t\tbrick_width *= (rownum % squash_frequency != 0) ? 1.0 : squash_amount; /* squash */\n\t\toffset = (rownum % offset_frequency != 0) ? 0.0 : (brick_width * offset_amount); /* offset */\n\t}\n\n\tbricknum = floor_to_int((p.x + offset) / brick_width);\n\n\tx = (p.x + offset) - brick_width * bricknum;\n\ty = p.y - row_height * rownum;\n\n\treturn vec2(clamp((integer_noise((rownum << 16) + (bricknum & 0xFFFF)) + bias), 0.0, 1.0),\n\t            (x < mortar_size || y < mortar_size ||\n\t             x > (brick_width - mortar_size) ||\n\t             y > (row_height - mortar_size)) ? 1.0 : 0.0);\n}\n#endif\n\nvoid node_tex_brick(vec3 co,\n                    vec4 color1, vec4 color2,\n                    vec4 mortar, float scale,\n                    float mortar_size, float bias,\n                    float brick_width, float row_height,\n                    float offset_amount, float offset_frequency,\n                    float squash_amount, float squash_frequency,\n                    out vec4 color, out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tvec2 f2 = calc_brick_texture(co * scale,\n\t                             mortar_size, bias,\n\t                             brick_width, row_height,\n\t                             offset_amount, int(offset_frequency),\n\t                             squash_amount, int(squash_frequency));\n\tfloat tint = f2.x;\n\tfloat f = f2.y;\n\tif (f != 1.0) {\n\t\tfloat facm = 1.0 - tint;\n\t\tcolor1 = facm * color1 + tint * color2;\n\t}\n\tcolor = (f == 1.0) ? mortar : color1;\n\tfac = f;\n#else\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n#endif\n}\n\nvoid node_tex_clouds(vec3 co, float size, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_environment_equirectangular(vec3 co, sampler2D ima, out vec4 color)\n{\n\tvec3 nco = normalize(co);\n\tfloat u = -atan(nco.y, nco.x) / (2.0 * M_PI) + 0.5;\n\tfloat v = atan(nco.z, hypot(nco.x, nco.y)) / M_PI + 0.5;\n\n\tcolor = texture2D(ima, vec2(u, v));\n}\n\nvoid node_tex_environment_mirror_ball(vec3 co, sampler2D ima, out vec4 color)\n{\n\tvec3 nco = normalize(co);\n\n\tnco.y -= 1.0;\n\n\tfloat div = 2.0 * sqrt(max(-0.5 * nco.y, 0.0));\n\tif (div > 0.0)\n\t\tnco /= div;\n\n\tfloat u = 0.5 * (nco.x + 1.0);\n\tfloat v = 0.5 * (nco.z + 1.0);\n\n\tcolor = texture2D(ima, vec2(u, v));\n}\n\nvoid node_tex_environment_empty(vec3 co, out vec4 color)\n{\n\tcolor = vec4(1.0, 0.0, 1.0, 1.0);\n}\n\nvoid node_tex_image(vec3 co, sampler2D ima, out vec4 color, out float alpha)\n{\n\tcolor = texture2D(ima, co.xy);\n\talpha = color.a;\n}\n\nvoid node_tex_image_box(vec3 texco,\n                        vec3 nob,\n                        sampler2D ima,\n                        float blend,\n                        out vec4 color,\n                        out float alpha)\n{\n\t/* project from direction vector to barycentric coordinates in triangles */\n\tnob = vec3(abs(nob.x), abs(nob.y), abs(nob.z));\n\tnob /= (nob.x + nob.y + nob.z);\n\n\t/* basic idea is to think of this as a triangle, each corner representing\n\t * one of the 3 faces of the cube. in the corners we have single textures,\n\t * in between we blend between two textures, and in the middle we a blend\n\t * between three textures.\n\t *\n\t * the Nxyz values are the barycentric coordinates in an equilateral\n\t * triangle, which in case of blending, in the middle has a smaller\n\t * equilateral triangle where 3 textures blend. this divides things into\n\t * 7 zones, with an if () test for each zone */\n\n\tvec3 weight = vec3(0.0, 0.0, 0.0);\n\tfloat limit = 0.5 * (1.0 + blend);\n\n\t/* first test for corners with single texture */\n\tif (nob.x > limit * (nob.x + nob.y) && nob.x > limit * (nob.x + nob.z)) {\n\t\tweight.x = 1.0;\n\t}\n\telse if (nob.y > limit * (nob.x + nob.y) && nob.y > limit * (nob.y + nob.z)) {\n\t\tweight.y = 1.0;\n\t}\n\telse if (nob.z > limit * (nob.x + nob.z) && nob.z > limit * (nob.y + nob.z)) {\n\t\tweight.z = 1.0;\n\t}\n\telse if (blend > 0.0) {\n\t\t/* in case of blending, test for mixes between two textures */\n\t\tif (nob.z < (1.0 - limit) * (nob.y + nob.x)) {\n\t\t\tweight.x = nob.x / (nob.x + nob.y);\n\t\t\tweight.x = clamp((weight.x - 0.5 * (1.0 - blend)) / blend, 0.0, 1.0);\n\t\t\tweight.y = 1.0 - weight.x;\n\t\t}\n\t\telse if (nob.x < (1.0 - limit) * (nob.y + nob.z)) {\n\t\t\tweight.y = nob.y / (nob.y + nob.z);\n\t\t\tweight.y = clamp((weight.y - 0.5 * (1.0 - blend)) / blend, 0.0, 1.0);\n\t\t\tweight.z = 1.0 - weight.y;\n\t\t}\n\t\telse if (nob.y < (1.0 - limit) * (nob.x + nob.z)) {\n\t\t\tweight.x = nob.x / (nob.x + nob.z);\n\t\t\tweight.x = clamp((weight.x - 0.5 * (1.0 - blend)) / blend, 0.0, 1.0);\n\t\t\tweight.z = 1.0 - weight.x;\n\t\t}\n\t\telse {\n\t\t\t/* last case, we have a mix between three */\n\t\t\tweight.x = ((2.0 - limit) * nob.x + (limit - 1.0)) / (2.0 * limit - 1.0);\n\t\t\tweight.y = ((2.0 - limit) * nob.y + (limit - 1.0)) / (2.0 * limit - 1.0);\n\t\t\tweight.z = ((2.0 - limit) * nob.z + (limit - 1.0)) / (2.0 * limit - 1.0);\n\t\t}\n\t}\n\telse {\n\t\t/* Desperate mode, no valid choice anyway, fallback to one side.*/\n\t\tweight.x = 1.0;\n\t}\n\tcolor = vec4(0);\n\tif (weight.x > 0.0) {\n\t\tcolor += weight.x * texture2D(ima, texco.yz);\n\t}\n\tif (weight.y > 0.0) {\n\t\tcolor += weight.y * texture2D(ima, texco.xz);\n\t}\n\tif (weight.z > 0.0) {\n\t\tcolor += weight.z * texture2D(ima, texco.yx);\n\t}\n\n\talpha = color.a;\n}\n\nvoid node_tex_image_empty(vec3 co, out vec4 color, out float alpha)\n{\n\tcolor = vec4(0.0);\n\talpha = 0.0;\n}\n\nvoid node_tex_magic(vec3 co, float scale, float distortion, float depth, out vec4 color, out float fac)\n{\n\tvec3 p = co * scale;\n\tfloat x = sin((p.x + p.y + p.z) * 5.0);\n\tfloat y = cos((-p.x + p.y - p.z) * 5.0);\n\tfloat z = -cos((-p.x - p.y + p.z) * 5.0);\n\n\tif (depth > 0.0) {\n\t\tx *= distortion;\n\t\ty *= distortion;\n\t\tz *= distortion;\n\t\ty = -cos(x - y + z);\n\t\ty *= distortion;\n\t\tif (depth > 1.0) {\n\t\t\tx = cos(x - y - z);\n\t\t\tx *= distortion;\n\t\t\tif (depth > 2.0) {\n\t\t\t\tz = sin(-x - y - z);\n\t\t\t\tz *= distortion;\n\t\t\t\tif (depth > 3.0) {\n\t\t\t\t\tx = -cos(-x + y - z);\n\t\t\t\t\tx *= distortion;\n\t\t\t\t\tif (depth > 4.0) {\n\t\t\t\t\t\ty = -sin(-x + y + z);\n\t\t\t\t\t\ty *= distortion;\n\t\t\t\t\t\tif (depth > 5.0) {\n\t\t\t\t\t\t\ty = -cos(-x + y + z);\n\t\t\t\t\t\t\ty *= distortion;\n\t\t\t\t\t\t\tif (depth > 6.0) {\n\t\t\t\t\t\t\t\tx = cos(x + y + z);\n\t\t\t\t\t\t\t\tx *= distortion;\n\t\t\t\t\t\t\t\tif (depth > 7.0) {\n\t\t\t\t\t\t\t\t\tz = sin(x + y - z);\n\t\t\t\t\t\t\t\t\tz *= distortion;\n\t\t\t\t\t\t\t\t\tif (depth > 8.0) {\n\t\t\t\t\t\t\t\t\t\tx = -cos(-x - y + z);\n\t\t\t\t\t\t\t\t\t\tx *= distortion;\n\t\t\t\t\t\t\t\t\t\tif (depth > 9.0) {\n\t\t\t\t\t\t\t\t\t\t\ty = -sin(x - y + z);\n\t\t\t\t\t\t\t\t\t\t\ty *= distortion;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (distortion != 0.0) {\n\t\tdistortion *= 2.0;\n\t\tx /= distortion;\n\t\ty /= distortion;\n\t\tz /= distortion;\n\t}\n\n\tcolor = vec4(0.5 - x, 0.5 - y, 0.5 - z, 1.0);\n\tfac = (color.x + color.y + color.z) / 3.0;\n}\n\n#ifdef BIT_OPERATIONS\nfloat noise_fade(float t)\n{\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat noise_scale3(float result)\n{\n\treturn 0.9820 * result;\n}\n\nfloat noise_nerp(float t, float a, float b)\n{\n\treturn (1.0 - t) * a + t * b;\n}\n\nfloat noise_grad(uint hash, float x, float y, float z)\n{\n\tuint h = hash & 15u;\n\tfloat u = h < 8u ? x : y;\n\tfloat vt = ((h == 12u) || (h == 14u)) ? x : z;\n\tfloat v = h < 4u ? y : vt;\n\treturn (((h & 1u) != 0u) ? -u : u) + (((h & 2u) != 0u) ? -v : v);\n}\n\nfloat noise_perlin(float x, float y, float z)\n{\n\tint X; float fx = floorfrac(x, X);\n\tint Y; float fy = floorfrac(y, Y);\n\tint Z; float fz = floorfrac(z, Z);\n\n\tfloat u = noise_fade(fx);\n\tfloat v = noise_fade(fy);\n\tfloat w = noise_fade(fz);\n\n\tfloat result;\n\n\tresult = noise_nerp(w, noise_nerp(v, noise_nerp(u, noise_grad(hash(X, Y, Z), fx, fy, fz),\n\t                                                noise_grad(hash(X + 1, Y, Z), fx - 1.0, fy, fz)),\n\t                                  noise_nerp(u, noise_grad(hash(X, Y + 1, Z), fx, fy - 1.0, fz),\n\t                                             noise_grad(hash(X + 1, Y + 1, Z), fx - 1.0, fy - 1.0, fz))),\n\t                    noise_nerp(v, noise_nerp(u, noise_grad(hash(X, Y, Z + 1), fx, fy, fz - 1.0),\n\t                                             noise_grad(hash(X + 1, Y, Z + 1), fx - 1.0, fy, fz - 1.0)),\n\t                               noise_nerp(u, noise_grad(hash(X, Y + 1, Z + 1), fx, fy - 1.0, fz - 1.0),\n\t                                          noise_grad(hash(X + 1, Y + 1, Z + 1), fx - 1.0, fy - 1.0, fz - 1.0))));\n\treturn noise_scale3(result);\n}\n\nfloat noise(vec3 p)\n{\n\treturn 0.5 * noise_perlin(p.x, p.y, p.z) + 0.5;\n}\n\nfloat snoise(vec3 p)\n{\n\treturn noise_perlin(p.x, p.y, p.z);\n}\n\nfloat noise_turbulence(vec3 p, float octaves, int hard)\n{\n\tfloat fscale = 1.0;\n\tfloat amp = 1.0;\n\tfloat sum = 0.0;\n\tint i, n;\n\toctaves = clamp(octaves, 0.0, 16.0);\n\tn = int(octaves);\n\tfor (i = 0; i <= n; i++) {\n\t\tfloat t = noise(fscale * p);\n\t\tif (hard != 0) {\n\t\t\tt = abs(2.0 * t - 1.0);\n\t\t}\n\t\tsum += t * amp;\n\t\tamp *= 0.5;\n\t\tfscale *= 2.0;\n\t}\n\tfloat rmd = octaves - floor(octaves);\n\tif  (rmd != 0.0) {\n\t\tfloat t = noise(fscale * p);\n\t\tif (hard != 0) {\n\t\t\tt = abs(2.0 * t - 1.0);\n\t\t}\n\t\tfloat sum2 = sum + t * amp;\n\t\tsum *= (float(1 << n) / float((1 << (n + 1)) - 1));\n\t\tsum2 *= (float(1 << (n + 1)) / float((1 << (n + 2)) - 1));\n\t\treturn (1.0 - rmd) * sum + rmd * sum2;\n\t}\n\telse {\n\t\tsum *= (float(1 << n) / float((1 << (n + 1)) - 1));\n\t\treturn sum;\n\t}\n}\n#endif  // BIT_OPERATIONS\n\nvoid node_tex_noise(vec3 co, float scale, float detail, float distortion, out vec4 color, out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tvec3 p = co * scale;\n\tint hard = 0;\n\tif (distortion != 0.0) {\n\t\tvec3 r, offset = vec3(13.5, 13.5, 13.5);\n\t\tr.x = noise(p + offset) * distortion;\n\t\tr.y = noise(p) * distortion;\n\t\tr.z = noise(p - offset) * distortion;\n\t\tp += r;\n\t}\n\n\tfac = noise_turbulence(p, detail, hard);\n\tcolor = vec4(fac,\n\t             noise_turbulence(vec3(p.y, p.x, p.z), detail, hard),\n\t             noise_turbulence(vec3(p.y, p.z, p.x), detail, hard),\n\t             1);\n#else  // BIT_OPERATIONS\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n#endif  // BIT_OPERATIONS\n}\n\n\n#ifdef BIT_OPERATIONS\n\n/* Musgrave fBm\n *\n * H: fractal increment parameter\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n *\n * from \"Texturing and Modelling: A procedural approach\"\n */\n\nfloat noise_musgrave_fBm(vec3 p, float H, float lacunarity, float octaves)\n{\n\tfloat rmd;\n\tfloat value = 0.0;\n\tfloat pwr = 1.0;\n\tfloat pwHL = pow(lacunarity, -H);\n\tint i;\n\n\tfor (i = 0; i < int(octaves); i++) {\n\t\tvalue += snoise(p) * pwr;\n\t\tpwr *= pwHL;\n\t\tp *= lacunarity;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0)\n\t\tvalue += rmd * snoise(p) * pwr;\n\n\treturn value;\n}\n\n/* Musgrave Multifractal\n *\n * H: highest fractal dimension\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n */\n\nfloat noise_musgrave_multi_fractal(vec3 p, float H, float lacunarity, float octaves)\n{\n\tfloat rmd;\n\tfloat value = 1.0;\n\tfloat pwr = 1.0;\n\tfloat pwHL = pow(lacunarity, -H);\n\tint i;\n\n\tfor (i = 0; i < int(octaves); i++) {\n\t\tvalue *= (pwr * snoise(p) + 1.0);\n\t\tpwr *= pwHL;\n\t\tp *= lacunarity;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0)\n\t\tvalue *= (rmd * pwr * snoise(p) + 1.0); /* correct? */\n\n\treturn value;\n}\n\n/* Musgrave Heterogeneous Terrain\n *\n * H: fractal dimension of the roughest area\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n * offset: raises the terrain from `sea level'\n */\n\nfloat noise_musgrave_hetero_terrain(vec3 p, float H, float lacunarity, float octaves, float offset)\n{\n\tfloat value, increment, rmd;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\tint i;\n\n\t/* first unscaled octave of function; later octaves are scaled */\n\tvalue = offset + snoise(p);\n\tp *= lacunarity;\n\n\tfor (i = 1; i < int(octaves); i++) {\n\t\tincrement = (snoise(p) + offset) * pwr * value;\n\t\tvalue += increment;\n\t\tpwr *= pwHL;\n\t\tp *= lacunarity;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0) {\n\t\tincrement = (snoise(p) + offset) * pwr * value;\n\t\tvalue += rmd * increment;\n\t}\n\n\treturn value;\n}\n\n/* Hybrid Additive/Multiplicative Multifractal Terrain\n *\n * H: fractal dimension of the roughest area\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n * offset: raises the terrain from `sea level'\n */\n\nfloat noise_musgrave_hybrid_multi_fractal(vec3 p, float H, float lacunarity, float octaves, float offset, float gain)\n{\n\tfloat result, signal, weight, rmd;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\tint i;\n\n\tresult = snoise(p) + offset;\n\tweight = gain * result;\n\tp *= lacunarity;\n\n\tfor (i = 1; (weight > 0.001f) && (i < int(octaves)); i++) {\n\t\tif (weight > 1.0)\n\t\t\tweight = 1.0;\n\n\t\tsignal = (snoise(p) + offset) * pwr;\n\t\tpwr *= pwHL;\n\t\tresult += weight * signal;\n\t\tweight *= gain * signal;\n\t\tp *= lacunarity;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0)\n\t\tresult += rmd * ((snoise(p) + offset) * pwr);\n\n\treturn result;\n}\n\n/* Ridged Multifractal Terrain\n *\n * H: fractal dimension of the roughest area\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n * offset: raises the terrain from `sea level'\n */\n\nfloat noise_musgrave_ridged_multi_fractal(vec3 p, float H, float lacunarity, float octaves, float offset, float gain)\n{\n\tfloat result, signal, weight;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\tint i;\n\n\tsignal = offset - abs(snoise(p));\n\tsignal *= signal;\n\tresult = signal;\n\tweight = 1.0;\n\n\tfor (i = 1; i < int(octaves); i++) {\n\t\tp *= lacunarity;\n\t\tweight = clamp(signal * gain, 0.0, 1.0);\n\t\tsignal = offset - abs(snoise(p));\n\t\tsignal *= signal;\n\t\tsignal *= weight;\n\t\tresult += signal * pwr;\n\t\tpwr *= pwHL;\n\t}\n\n\treturn result;\n}\n\nfloat svm_musgrave(int type,\n                   float dimension,\n                   float lacunarity,\n                   float octaves,\n                   float offset,\n                   float intensity,\n                   float gain,\n                   vec3 p)\n{\n\tif (type == 0 /*NODE_MUSGRAVE_MULTIFRACTAL*/)\n\t\treturn intensity * noise_musgrave_multi_fractal(p, dimension, lacunarity, octaves);\n\telse if (type == 1 /*NODE_MUSGRAVE_FBM*/)\n\t\treturn intensity * noise_musgrave_fBm(p, dimension, lacunarity, octaves);\n\telse if (type == 2 /*NODE_MUSGRAVE_HYBRID_MULTIFRACTAL*/)\n\t\treturn intensity * noise_musgrave_hybrid_multi_fractal(p, dimension, lacunarity, octaves, offset, gain);\n\telse if (type == 3 /*NODE_MUSGRAVE_RIDGED_MULTIFRACTAL*/)\n\t\treturn intensity * noise_musgrave_ridged_multi_fractal(p, dimension, lacunarity, octaves, offset, gain);\n\telse if (type == 4 /*NODE_MUSGRAVE_HETERO_TERRAIN*/)\n\t\treturn intensity * noise_musgrave_hetero_terrain(p, dimension, lacunarity, octaves, offset);\n\treturn 0.0;\n}\n#endif  // #ifdef BIT_OPERATIONS\n\nvoid node_tex_musgrave(vec3 co,\n                       float scale,\n                       float detail,\n                       float dimension,\n                       float lacunarity,\n                       float offset,\n                       float gain,\n                       float type,\n                       out vec4 color,\n                       out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tfac = svm_musgrave(int(type),\n\t                   dimension,\n\t                   lacunarity,\n\t                   detail,\n\t                   offset,\n\t                   1.0,\n\t                   gain,\n\t                   co * scale);\n#else\n\tfac = 1.0;\n#endif\n\n\tcolor = vec4(fac, fac, fac, 1.0);\n}\n\nvoid node_tex_sky(vec3 co, out vec4 color)\n{\n\tcolor = vec4(1.0);\n}\n\nvoid node_tex_voronoi(vec3 co, float scale, float coloring, out vec4 color, out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tvec3 p = co * scale;\n\tint xx, yy, zz, xi, yi, zi;\n\tfloat da[4];\n\tvec3 pa[4];\n\n\txi = floor_to_int(p[0]);\n\tyi = floor_to_int(p[1]);\n\tzi = floor_to_int(p[2]);\n\n\tda[0] = 1e+10;\n\tda[1] = 1e+10;\n\tda[2] = 1e+10;\n\tda[3] = 1e+10;\n\n\tfor (xx = xi - 1; xx <= xi + 1; xx++) {\n\t\tfor (yy = yi - 1; yy <= yi + 1; yy++) {\n\t\t\tfor (zz = zi - 1; zz <= zi + 1; zz++) {\n\t\t\t\tvec3 ip = vec3(xx, yy, zz);\n\t\t\t\tvec3 vp = cellnoise_color(ip);\n\t\t\t\tvec3 pd = p - (vp + ip);\n\t\t\t\tfloat d = dot(pd, pd);\n\t\t\t\tvp += vec3(xx, yy, zz);\n\t\t\t\tif (d < da[0]) {\n\t\t\t\t\tda[3] = da[2];\n\t\t\t\t\tda[2] = da[1];\n\t\t\t\t\tda[1] = da[0];\n\t\t\t\t\tda[0] = d;\n\t\t\t\t\tpa[3] = pa[2];\n\t\t\t\t\tpa[2] = pa[1];\n\t\t\t\t\tpa[1] = pa[0];\n\t\t\t\t\tpa[0] = vp;\n\t\t\t\t}\n\t\t\t\telse if (d < da[1]) {\n\t\t\t\t\tda[3] = da[2];\n\t\t\t\t\tda[2] = da[1];\n\t\t\t\t\tda[1] = d;\n\n\t\t\t\t\tpa[3] = pa[2];\n\t\t\t\t\tpa[2] = pa[1];\n\t\t\t\t\tpa[1] = vp;\n\t\t\t\t}\n\t\t\t\telse if (d < da[2]) {\n\t\t\t\t\tda[3] = da[2];\n\t\t\t\t\tda[2] = d;\n\n\t\t\t\t\tpa[3] = pa[2];\n\t\t\t\t\tpa[2] = vp;\n\t\t\t\t}\n\t\t\t\telse if (d < da[3]) {\n\t\t\t\t\tda[3] = d;\n\t\t\t\t\tpa[3] = vp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (coloring == 0.0) {\n\t\tfac = abs(da[0]);\n\t\tcolor = vec4(fac, fac, fac, 1);\n\t}\n\telse {\n\t\tcolor = vec4(cellnoise_color(pa[0]), 1);\n\t\tfac = (color.x + color.y + color.z) * (1.0 / 3.0);\n\t}\n#else  // BIT_OPERATIONS\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n#endif  // BIT_OPERATIONS\n}\n\n#ifdef BIT_OPERATIONS\nfloat calc_wave(vec3 p, float distortion, float detail, float detail_scale, int wave_type, int wave_profile)\n{\n\tfloat n;\n\n\tif (wave_type == 0) /* type bands */\n\t\tn = (p.x + p.y + p.z) * 10.0;\n\telse /* type rings */\n\t\tn = length(p) * 20.0;\n\n\tif (distortion != 0.0)\n\t\tn += distortion * noise_turbulence(p * detail_scale, detail, 0);\n\n\tif (wave_profile == 0) { /* profile sin */\n\t\treturn 0.5 + 0.5 * sin(n);\n\t}\n\telse { /* profile saw */\n\t\tn /= 2.0 * M_PI;\n\t\tn -= int(n);\n\t\treturn (n < 0.0) ? n + 1.0 : n;\n\t}\n}\n#endif  // BIT_OPERATIONS\n\nvoid node_tex_wave(\n        vec3 co, float scale, float distortion, float detail, float detail_scale, float wave_type, float wave_profile,\n        out vec4 color, out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tfloat f;\n\tf = calc_wave(co * scale, distortion, detail, detail_scale, int(wave_type), int(wave_profile));\n\n\tcolor = vec4(f, f, f, 1.0);\n\tfac = f;\n#else  // BIT_OPERATIONS\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n#endif  // BIT_OPERATIONS\n}\n\n/* light path */\n\nvoid node_light_path(\n\tout float is_camera_ray,\n\tout float is_shadow_ray,\n\tout float is_diffuse_ray,\n\tout float is_glossy_ray,\n\tout float is_singular_ray,\n\tout float is_reflection_ray,\n\tout float is_transmission_ray,\n\tout float ray_length,\n\tout float ray_depth,\n\tout float transparent_depth,\n\tout float transmission_depth)\n{\n\tis_camera_ray = 1.0;\n\tis_shadow_ray = 0.0;\n\tis_diffuse_ray = 0.0;\n\tis_glossy_ray = 0.0;\n\tis_singular_ray = 0.0;\n\tis_reflection_ray = 0.0;\n\tis_transmission_ray = 0.0;\n\tray_length = 1.0;\n\tray_depth = 1.0;\n\ttransparent_depth = 1.0;\n\ttransmission_depth = 1.0;\n}\n\nvoid node_light_falloff(float strength, float tsmooth, out float quadratic, out float linear, out float constant)\n{\n\tquadratic = strength;\n\tlinear = strength;\n\tconstant = strength;\n}\n\nvoid node_object_info(out vec3 location, out float object_index, out float material_index, out float random)\n{\n\tlocation = vec3(0.0);\n\tobject_index = 0.0;\n\tmaterial_index = 0.0;\n\trandom = 0.0;\n}\n\nvoid node_normal_map(vec4 tangent, vec3 normal, vec3 texnormal, out vec3 outnormal)\n{\n\tvec3 B = tangent.w * cross(normal, tangent.xyz);\n\n\toutnormal = texnormal.x * tangent.xyz + texnormal.y * B + texnormal.z * normal;\n\toutnormal = normalize(outnormal);\n}\n\nvoid node_bump(float strength, float dist, float height, vec3 N, vec3 surf_pos, float invert, out vec3 result)\n{\n\tif (invert != 0.0) {\n\t\tdist *= -1.0;\n\t}\n\tvec3 dPdx = dFdx(surf_pos);\n\tvec3 dPdy = dFdy(surf_pos);\n\n\t/* Get surface tangents from normal. */\n\tvec3 Rx = cross(dPdy, N);\n\tvec3 Ry = cross(N, dPdx);\n\n\t/* Compute surface gradient and determinant. */\n\tfloat det = dot(dPdx, Rx);\n\tfloat absdet = abs(det);\n\n\tfloat dHdx = dFdx(height);\n\tfloat dHdy = dFdy(height);\n\tvec3 surfgrad = dHdx * Rx + dHdy * Ry;\n\n\tstrength = max(strength, 0.0);\n\n\tresult = normalize(absdet * N - dist * sign(det) * surfgrad);\n\tresult = normalize(strength * result + (1.0 - strength) * N);\n}\n\n/* output */\n\nvoid node_output_material(vec4 surface, vec4 volume, float displacement, out vec4 result)\n{\n\tresult = surface;\n}\n\nvoid node_output_world(vec4 surface, vec4 volume, out vec4 result)\n{\n\tresult = surface;\n}\n\n/* ********************** matcap style render ******************** */\n\nvoid material_preview_matcap(vec4 color, sampler2D ima, vec4 N, vec4 mask, out vec4 result)\n{\n\tvec3 normal;\n\tvec2 tex;\n\t\n#ifndef USE_OPENSUBDIV\n\t/* remap to 0.0 - 1.0 range. This is done because OpenGL 2.0 clamps colors\n\t * between shader stages and we want the full range of the normal */\n\tnormal = vec3(2.0, 2.0, 2.0) * vec3(N.x, N.y, N.z) - vec3(1.0, 1.0, 1.0);\n\tif (normal.z < 0.0) {\n\t\tnormal.z = 0.0;\n\t}\n\tnormal = normalize(normal);\n#else\n\tnormal = inpt.v.normal;\n\tmask = vec4(1.0, 1.0, 1.0, 1.0);\n#endif\n\n\ttex.x = 0.5 + 0.49 * normal.x;\n\ttex.y = 0.5 + 0.49 * normal.y;\n\tresult = texture2D(ima, tex) * mask;\n}","type":"SHADER_LIB"},{"attributes":[],"double_sided":false,"type":"MATERIAL","fragment":"\n\nuniform vec3 unf1;\nvarying vec3 varnormal;\nvarying vec3 varposition;\nuniform vec3 unf11;\nuniform float unf15;\nuniform float unf25;\nuniform float unf27;\nuniform vec3 unf28;\nconst float cons33 = float(1.000000);\nconst vec4 cons37 = vec4(1.000000, 1.000000, 1.000000, 0.005000);\nuniform float unf48;\nuniform float unf51;\nuniform vec3 unf57;\nconst float cons67 = float(1.000000);\nuniform vec4 unf68;\nuniform vec3 unf70;\nconst float cons78 = float(1.000000);\nuniform float unf81;\nuniform float unf82;\nuniform float unf83;\nuniform float unf84;\nuniform float unf85;\nuniform vec4 unf89;\n\nvoid main()\n{\n\tvec3 facingnormal = gl_FrontFacing? varnormal: -varnormal;\n\tvec3 tmp2;\n\tvec4 tmp3;\n\tvec3 tmp5;\n\tvec3 tmp7;\n\tvec3 tmp8;\n\tvec3 tmp9;\n\tvec3 tmp12;\n\tfloat tmp13;\n\tfloat tmp14;\n\tfloat tmp17;\n\tfloat tmp19;\n\tfloat tmp22;\n\tfloat tmp26;\n\tvec3 tmp29;\n\tvec4 tmp32;\n\tfloat tmp34;\n\tvec4 tmp38;\n\tfloat tmp40;\n\tvec4 tmp44;\n\tfloat tmp49;\n\tfloat tmp54;\n\tvec3 tmp58;\n\tvec4 tmp61;\n\tvec4 tmp63;\n\tvec4 tmp65;\n\tvec4 tmp69;\n\tvec3 tmp73;\n\tvec4 tmp76;\n\tvec4 tmp79;\n\tfloat tmp86;\n\tvec4 tmp90;\n\tvec4 tmp92;\n\tvec4 tmp94;\n\n\tset_rgb(unf1, tmp2);\n\tset_rgba_zero(tmp3);\n\tshade_norm(facingnormal, tmp5);\n\tshade_view(varposition, tmp7);\n\tset_rgb_zero(tmp8);\n\tset_rgb_zero(tmp9);\n\tlamp_visibility_other(varposition, unf11, tmp12, tmp13, tmp14);\n\tlamp_falloff_invsquare(unf15, tmp13, tmp17);\n\tlamp_visibility_clamp(tmp17, tmp19);\n\tshade_inp(tmp5, tmp12, tmp22);\n\tshade_visifac(tmp22, tmp19, unf25, tmp26);\n\tshade_mul_value_v3(unf27, unf28, tmp29);\n\tshade_mul_value(tmp26, vec4(tmp29, 1.0), tmp32);\n\tmtex_value_invert(cons33, tmp34);\n\tmix_mult(tmp34, tmp32, cons37, tmp38);\n\tmtex_value_invert(tmp34, tmp40);\n\tshade_madd(vec4(tmp8, 1.0), tmp38, vec4(tmp2, 1.0), tmp44);\n\tshade_cooktorr_spec(tmp5, tmp12, tmp7, unf48, tmp49);\n\tshade_spec_t(tmp40, unf51, tmp19, tmp49, tmp54);\n\tshade_add_spec(tmp54, tmp29, unf57, tmp58);\n\tshade_add_clamped(vec4(tmp9, 1.0), vec4(tmp58, 1.0), tmp61);\n\tshade_clamp_positive(tmp61, tmp63);\n\tshade_clamp_positive(tmp44, tmp65);\n\tshade_maddf(tmp65, cons67, unf68, tmp69);\n\tshade_add_mirror(unf70, tmp3, tmp69.rgb, tmp73);\n\tshade_add(vec4(tmp73, 1.0), tmp63, tmp76);\n\tmtex_alpha_to_col(tmp76, cons78, tmp79);\n\tshade_mist_factor(varposition, unf81, unf82, unf83, unf84, unf85, tmp86);\n\tmix_blend(tmp86, tmp79, unf89, tmp90);\n\tshade_alpha_opaque(tmp90, tmp92);\n\tlinearrgb_to_srgb(tmp92, tmp94);\n\n\tgl_FragColor = tmp94;\n}","scene":"Scene","params":[{"emit":0.0,"alpha":1.0,"diffuse_color":[0.800000011920929,0.800000011920929,0.800000011920929],"specular_intensity":0.5,"diffuse_intensity":0.800000011920929,"specular_hardness":50,"name":"Material","specular_color":[1.0,1.0,1.0]}],"name":"Material","uniforms":[{"varname":"unf1","type":458753,"material":"Material","datatype":4},{"lamp":"Lamp","varname":"unf11","datatype":4,"type":131074},{"lamp":"Lamp","varname":"unf15","datatype":2,"type":131079},{"varname":"unf25","type":458754,"material":"Material","datatype":2},{"lamp":"Lamp","varname":"unf27","datatype":2,"type":131077},{"lamp":"Lamp","varname":"unf28","datatype":4,"type":131078},{"varname":"unf48","type":458757,"material":"Material","datatype":2},{"varname":"unf51","type":458756,"material":"Material","datatype":2},{"varname":"unf57","type":458755,"material":"Material","datatype":4},{"varname":"unf68","datatype":5,"type":393218},{"varname":"unf70","type":458761,"material":"Material","datatype":4},{"varname":"unf81","datatype":2,"type":327681},{"varname":"unf82","datatype":2,"type":327682},{"varname":"unf83","datatype":2,"type":327683},{"varname":"unf84","datatype":2,"type":327685},{"varname":"unf85","datatype":2,"type":327684},{"varname":"unf89","datatype":5,"type":327686}]}]